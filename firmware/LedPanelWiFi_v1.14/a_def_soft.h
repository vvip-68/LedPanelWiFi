// Определения программных констант и переменных (параметры эффектов и т.п.)

// При запуске микроконтроллера выполняется инициализация всех параметров значениями, сохраненными в EEPROM (функция loadSettings() в eeprom.ino)
// При этом если флаг EEPROM_OK в строке 7 этого файла был изменен и не совпадает со считанными яз ячейки #0 значением -
// выполняется инициализация параметров значениями по умолчанию (функция loadSettings() в eeprom.ino, ветвь if (isInitialized) -> false )

#define EEPROM_OK     0xE3                         // Флаг, показывающий, что EEPROM инициализирована корректными данными 

// ******************* ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ подключения к сети *********************

// Внимание!!! Если вы меняете эти значения ПОСЛЕ того, как прошивка уже хотя бы раз была загружена в плату и выполнялась,
// чтобы изменения вступили в силу нужно также изменить значение константы EEPROM_OK в строке 7 этого файла (см.выше)
// или в Arduino IDE в меню "Инструменты" 
//  для esp8266 -> "Erase Flash" выбрать значение "All Flash Contents"
//  для esp32   -> "Erase All Flash Before Sketch Upload" выбрать значение true

// ------------------------ Локальная сеть ---------------------

#ifndef NETWORK_SSID
#define NETWORK_SSID PSTR("your-ssid")             // Имя WiFi сети
#endif

#ifndef NETWORK_PASS
#define NETWORK_PASS PSTR("your-password")         // Пароль для подключения к WiFi сети
#endif

#ifndef DEFAULT_IP
#define DEFAULT_IP {192, 168, 0, 100}              // Сетевой адрес устройства по умолчанию или { 0, 0, 0, 0 } для получения адреса по DHCP
#endif

#ifndef GTW
#define GTW     1                                  // Последняя цифра в IP адресе роутера. Обычно IP роутера 192.168.0.*1*, но некоторые роутеры имеют адрес 192.168.0.100 или 192.168.0.254
#endif                                             // Тогда здесь вместо *1* должно быть 100 или 254 соответственно (используется в случае задания статического IP адреса выше)

// ---------------------------------------------------------------

#ifndef BRIGHTNESS
#define BRIGHTNESS      32                         // Яркость матрицы по-умолчанию 0..255
#endif

// ------------------------ Сервер времени ---------------------

#define DEFAULT_NTP_SERVER PSTR("ntp0.ntp-servers.net") // NTP сервер по умолчанию "time.nist.gov"
#define DEFAULT_AP_NAME    PSTR("PanelAP")              // Имя точки доступа по умолчанию 
#define DEFAULT_AP_PASS    PSTR("12341234")             // Пароль точки доступа по умолчанию

// ------------ Настройки региона погоды и часового пояса

#ifndef TZONE
#define TZONE PSTR("349_MSK-3")                  // Правило смещения часового пояса от UTC для вашего города, из файла временнЫх зон web/src/assets/tz-???.json - значение поля "value" для города Москва - с индексом '349_'
                                                 // Найдите указанный файл определения временнЫх зон, найдите поиском ваш город или ближайший, расположенный в том же часовом поясе. Возьмите значение поля "value" и вставьте
                                                 // его сюда, внутрь конструкции PSTR(""). Или оставьте это значение как есть. По умолчанию - это часовой пояс для Москвы. В WebUI на закладке "Часы" вы сможете настроить свою временнУю зону
#endif
                                                 
#ifndef WEATHER_REGION_YDX
#define WEATHER_REGION_YDX 62                    // Код региона погоды по Yandex
#endif

#ifndef WEATHER_REGION_OWM
#define WEATHER_REGION_OWM 1502026               // Код региона погоды по OpenWeatherMap
#endif

// *************************************************************************
// *************************************************************************
// *************************************************************************
// *************************************************************************
// *************************************************************************
// *************************************************************************
// *************************************************************************
// ДАЛЕЕ ИДУТ ТОНКИЕ  НАСТРОЙКИ ПРОШИВКИ И РАЗДЕЛ ОБЪЯВЛЕНИЯ ПЕРЕМЕННЫХ
// ТОЛЬКО ДЛЯ ПРОДВИНУТЫХ ПРОГРАММИСТОВ, РЕШИВШИХ ИЗМЕНИТЬ КОД ПРОШИВКИ
// *************************************************************************
// *************************************************************************
// *************************************************************************
// *************************************************************************
// *************************************************************************
// *************************************************************************
//
// Ниже представлен список эффектов, поддерживаемых прошивкой. Нумерация - сплошная от ID = 0 до ID = MAX_EFFECT
// Нумерация эффектов должна соответствовать позиции эффекта в списке EFFECT_LIST (см. определение в файле a_def_lang.h) так, чтобы названия и порядок эффектов
// соответствовал списку, определенному ниже.

// ID эффектов
#define MC_CLOCK                 0         // Режим отображения часов (когда "Ночные часы" или просто "Часы" на черном фоне, а не как оверлей поверх других эффектов
#define MC_FILL_COLOR            1
#define MC_SNOW                  2
#define MC_BALL                  3
#define MC_RAINBOW               4
#define MC_PAINTBALL             5
#define MC_FIRE                  6
#define MC_MATRIX                7
#define MC_WORMS                 8
#define MC_STARFALL              9
#define MC_SPARKLES             10
#define MC_NOISE_MADNESS        11
#define MC_NOISE_CLOUD          12
#define MC_NOISE_LAVA           13
#define MC_NOISE_PLASMA         14
#define MC_NOISE_RAINBOW        15
#define MC_NOISE_RAINBOW_STRIP  16
#define MC_NOISE_ZEBRA          17
#define MC_NOISE_FOREST         18
#define MC_NOISE_OCEAN          19
#define MC_COLORS               20
#define MC_LIGHTERS             21
#define MC_SWIRL                22
#define MC_CYCLON               23
#define MC_FLICKER              24
#define MC_PACIFICA             25
#define MC_SHADOWS              26
#define MC_MAZE                 27
#define MC_SNAKE                28
#define MC_TETRIS               29
#define MC_ARKANOID             30
#define MC_PALETTE              31
#define MC_ANALYZER             32
#define MC_PRIZMATA             33
#define MC_MUNCH                34
#define MC_RAIN                 35
#define MC_FIRE2                36
#define MC_ARROWS               37
#define MC_PATTERNS             38
#define MC_RUBIK                39
#define MC_STARS                40
#define MC_STARS2               41
#define MC_TRAFFIC              42
#define MC_DAWN_ALARM           43
#define MC_PRIZMATA2            44
#define MC_FIREWORKS            45
#define MC_SHADOWS2             46

#define MC_IMAGE                47
#define MC_WEATHER              48
#define MC_SLIDE                49
#define MC_SDCARD               50

#define MAX_EFFECT_SUPPORT      51         // Количество эффектов, максимально поддерживаемых прошивкой (служит для выделения памяти под массивы параметров) 

uint8_t MAX_EFFECT = 0;                    // Количество эффектов, реально определенных в прошивке с учетом ключей компиляции

#define MAX_SPEC_EFFECT          7         // количество эффектов быстрого доступа определенных в прошивке -> 0..6
#define SPECIAL_EFFECTS_START  120         // Некоторые специальные "служебные" эффекты имеют код >= SPECIAL_EFFECTS_START

                                           // Внимание !!! - для идентификатора режима используется тип int8_t (-128..127, нужно значение -1), поэтому код режима не может быть больше 127 !!!
#define MC_DRAW                123         // Режим рисования картинки на телефоне
#define MC_LOADIMAGE           124         // Режим загрузки изображения с телефона
#define MC_TEXT                125         // Режим бегущей строки (для отображения IP адреса) - бегущая строка на черном фоне
#define MC_DAWN_ALARM_SPIRAL   126         // Специальный режим, вызывается из DEMO_DAWN_ALARM для ламп на круговой матрице - огонек по спирали
#define MC_DAWN_ALARM_SQUARE   127         // Специальный режим, вызывается из DEMO_DAWN_ALARM для плоских матриц - огонек по спирали на плоскости матрицы

// Строка преобразования номера эффекта (индекса) в букву алфавита для сокращения объема передачи строки упорядочивания эффектов
// Буквы кодируют 62 эффекта. Сейчас их 48/49 (MAX_EFFECT) - при необходимоости расширить, добавив другие символы
#define IDX_LINE F("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")

// Строка, определяющая порядок воспроизведения эффектов, если не используется Random-режим. По умолчанию порядок следования - от эффекта ID=0 до ID=MAX_EFFECT-1;
// В EEPROM хранятся блоки описания параметров эффектов (с адреса EFFECT_EEPROM и далее 10 байт на эффект). 
// В блоке байт 'order' хранит порядковый номер очередности воспроизведения эффектов, начиная с 0. Значение в этом байте 255 означает "не использовать"
// Инициализация строки порядка очередности происходит в процедуре loadEffectOrder() в eeprom.ino - читаются последовательно все блоки эффектов, из каждого блока извлекается порядковый номер
// и ID эффекта приведенный к символу из IDX_LINE записывается в соответствующую позицию строки effect_order.  
// Пример строки effect_order = "FR1H5aShik" - определено 10 эффектов в порядке их использования. Позиция буквы (индекс) в строке - порядок чередования эффектов.
// Буква, кодирующая ID эффекта - по индексу буквы в строке IDX_LINE определяется ID эффекта. Например буква F соответствует эффекту с ID=15 - MC_NOISE_RAINBOW
String  effect_order;

// текущей индекс в строке effect_order - изменяется от 0 до конец строки, после чего возвращается в 0 
// при режиме последовательного перебора избранных эффектовю При случайном выборе эффекта соответствует позиции
// текущего выбранного эффекта в строке доступных (избранных) эффектов effect_order
uint8_t effect_order_idx = 0;

// *************************************************************************

enum  eModes   {NORMAL, COLOR, TEXT}        parseMode; // Текущий режим парсера

// ********************* ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ ЧАСОВ **********************

#define D_CLOCK_SPEED 255                   // скорость перемещения эффекта часов по умолчанию (мс) - если 255 - часы стоят, не прокручиваются
#define D_CLOCK_SPEED_MIN 2
#define D_CLOCK_SPEED_MAX 255

uint8_t CLOCK_SIZE = 0;                     // Размер горизонтальных часов: 0 - авто; 1 - цифры 3x5; 2 - цифры 5х7
uint8_t CLOCK_ORIENT = 0;                   // Ориентация отображения часов: 0 горизонтальные, 1 вертикальные
uint8_t CLOCK_MOVE_DIVIDER = 3;             // Делитель такта таймера эффектов для движения часов оверлея (режим прокручивания часов по горизонтали)
uint8_t CLOCK_MOVE_CNT = CLOCK_MOVE_DIVIDER;// Текущее значения счетчика сдвига 

uint8_t clockScrollSpeed = D_CLOCK_SPEED;   // Скорость прокрутки часов
uint8_t c_size = 0;                         // тип часов: 0 - авто; 1 - шрифт 3x5; 2 - шрифт 5х7; вычисляется в зависимости от настроек и параметров матрицы 
bool allow_two_row = false;                 // высота матрицы позволяет размещать календарь и часы с температурой в две строки или вертикальные часы 
bool time_h12 = false;                      // Время - в 12-часовом формате

int8_t   CLOCK_XC    = 0;                   // Текущая позиция центра часов (разделительные точки) по оси Х с учетом скроллинга
int8_t   CLOCK_LX    = 0;                   // Реальная X позиция отрисовки последней цифры часов - температура будет выводиться от этой позиции влево, чтобы выровнять температуру по правому краю часов

int8_t   debug_hours = -1;                  // Для отладки позиционирования часов / температуры / календаря
int8_t   debug_mins = -1;
int8_t   debug_temperature = 0;
int8_t   debug_days = -1;
int8_t   debug_month = -1;
int16_t  debug_year = -1;
int8_t   debug_move = 0;
bool     debug_cross = false;

// Часы могут отображаться: 
// - вертикальные при высоте матрицы >= 11 и ширине >= 7; 
// - горизонтальные при ширене матрицы >= 15 и высоте >= 5
// минимальная ширина горизонтальных часов - 15 символов, т.к если большие часы не помещаются по ширине - автоматически используются маленькие часы

bool   allowVertical, allowHorizontal;

uint8_t  COLOR_MODE = 0;                    // Режим цвета часов
                                            //  0 - монохром
                                            //  1 - радужная смена (каждая цифра)
                                            //  2 - радужная смена (часы, точки, минуты)
                                            //  3 - заданные цвета (часы, точки, минуты) - HOUR_COLOR, DOT_COLOR, MIN_COLOR в clock.ino

#define  MIN_NIGHT_CLOCK_BRIGHTNESS 16      // Минимальная яркость ночных часов при которой диоды еще светятся
uint8_t  nightClockBrightness = 16;         // Яркость отображения ночных часов
uint8_t  nightClockColor = 0;               // Цвет ночных часов: 0 - R; 1 - G; 2 - B; 3 - C; 4 - M; 5 - Y; 6 - W;
bool     needTurnOffClock = false;          // Выключать индикатор часов TM1637 при выключении устройства (true); если False - при отключении панели индикатор TM1637 продолжает показывать текущее время
 
bool     showWeatherInClock = true;         // Показывать текущую температуру при отображении малых (неподвижных) часов
bool     showDateInClock = true;            // Показывать дату при отображении часов
uint8_t  showDateDuration = 2;              // на 2 секунды
uint8_t  showDateInterval = 240;            // через каждые 240 секунд
bool     showDateState = false;             // false - отображаются часы; true - отображается дата
bool     showWeatherState = false;          // false - отображаются часы; true - отображается температура в больших часах
uint32_t showDateStateLastChange = 0;       // Время, когда отображение часов сменилось на отображение календаря и наоборот

int8_t   hrs = 0, mins = 0, sec = 0;        // Для получения текущего времени. Инициализировано как 01.01.1970 00:00
int8_t   secs = 0, aday = 1, amnth = 1;
int16_t  ayear = 1970;
bool     dotFlag;                           // флаг: в часах рисуется точки 

// ************************ НАСТРОЙКИ БЕГУЩЕЙ СТРОКИ ***********************

#define D_TEXT_SPEED 200                    // скорость перемещения бегущей строки по умолчанию (мс)
#define D_TEXT_SPEED_MIN 1
#define D_TEXT_SPEED_MAX 254

#define MIRR_V 0                            // отразить текст по вертикали (0 / 1)
#define MIRR_H 0                            // отразить текст по горизонтали (0 / 1)

#if (BIG_FONT == 0)
  #define LET_WIDTH 5                       // ширина буквы шрифта
  #define LET_HEIGHT 8                      // высота буквы шрифта
  #define SPACE 1                           // пробел между буквами
#elif (BIG_FONT == 1)
  #define LET_WIDTH 10                      // ширина буквы шрифта
  #define LET_HEIGHT 16                     // высота буквы шрифта
  #define SPACE 2                           // пробел между буквами
#else  
  #define LET_WIDTH 8                       // ширина буквы шрифта
  #define LET_HEIGHT 13                     // высота буквы шрифта
  #define SPACE 1                           // пробел между буквами
#endif

uint8_t  textScrollSpeed = D_TEXT_SPEED;    // Скорость прокрутки оверлея бегущей строки

uint16_t TEXT_INTERVAL = 600;               // Интервал (время в секундах) между отображением строк
                                            // следующая бегущая строка будет отображена через указанное кол-во секунд
                                            // 0 - отключено, следующая строка отображается после завершения текущей
                                         
uint8_t  COLOR_TEXT_MODE = 0;               // Режим цвета текста бегущей строки и самой бегущей строки
                                            //  0 - монохром
                                            //  1 - радужная смена (каждая цифра)
                                            //  2 - каждая цифра свой цвет
                                         
// --- Параметры отображения текущей бегущей строки
static const char FS_TEXT_STORAGE[] PROGMEM = "/web/assets/txt"; // Все строки хранятся в файловой системе микроконтроллера в папке '/web/assets/txt'
static const char FS_BACK_STORAGE[] PROGMEM = "/web/assets";     // Backup хранится в файловой системе микроконтроллера в папке '/web/assets'
static const char SD_BACK_STORAGE[] PROGMEM = "/";               // Backup на SD-карте хранится в корневой папке '/'

uint8_t  TEXTS_MAX_COUNT = 0;               // Сколько строк поддерживается. Инициализируется в InitializeTextx()
String   textIndecies;                      // Индексы (порядок следования) текстов бегущей строки (строка с индексом '0' из хранилиша)
String   textStates;                        // Строка статусов бегущих строк - длина TEXTS_MAX_COUNT (кол-во строк), каждый символ - 0..5 - статус строки
int16_t  textShowTime = -1;                 // Если больше нуля - сколько времени отображать бегущую строку в секундах; Если 0 - используется textShowCount; В самой строке спец-макросом может быть указано кол-во секунд
uint8_t  textShowCount = 1;                 // Сколько раз прокручивать текст бегущей строки поверх эффектов; По умолчанию - 1; В самой строке спец-макросом может быть указано число 
uint8_t  textCurrentCount = 0;              // Сколько раз текст очередной бегущей строки поверх эффектов уже показан
bool     useSpecialTextColor = false;       // В текущей бегущей строке был задан цвет, которым она должна отображаться
uint32_t specialTextColor = 0xffffff;       // Цвет отображения бегущей строки, может быть указан макросом в строке. Если не указан - используются глобальные настройки цвета бегущей строки
bool     useSpecialBackColor = false;       // В текущей бегущей строке был задан цвет фона, на котором она должна отображаться
uint32_t specialBackColor = 0x000000;       // Цвет фона отображения бегущей строки, может быть указан макросом в строке. Если не указан - наложение на текущий эффект
int8_t   specialTextEffect = -1;            // Эффект, который нужно включить при начале отображения строки текста, может быть указан макросом в строке.
int8_t   specialTextEffectParam = -1;       // Параметр для эффекта (см. выше). Например эффект MC_SDCARD имеет более 40 подэффектов. Номер подэффекта хранится в этой переменной, извлекается из макроса {E}
int8_t   saveEffectBeforeText = -1;         // Если указан эффект на котором отображать строку, сохранить текущий эффект тут, чтобы по завершению строки восстановить его
int8_t   currentTextLineIdx = -1;           // Какая строка из массива строк показывается в текущий момент
int8_t   macrosTextLineIdx = -1;            // Какая строка из массива строк была обработана на предмет разбора макросов последней
int8_t   nextTextLineIdx = -1;              // Какую следующую строку показывать, может быть указан макросом в строке. Если указан - интервал отображения игнорируется, строка показывается сразу
bool     textHasDateTime = false;           // Строка содержит макрос отображения текущего времени - ее нужно пересчитывать каждый раз при отрисовке; Если макроса времени нет - рассчитать текст строки один раз на этапе инициализации
bool     textHasMultiColor = false;         // Строка содержит несколько (до 6) макросов, задающих цвет строки
String   currentText;                       // Текст текущей отображаемой строки
String   syncText;                          // Текст текущей отображаемой строки не очищенный от макросов
bool     ignoreTextOverlaySettingforEffect = false; // Показывать бегущую строку для эффекта, даже если настройки эффекта это запрещают; В строке может быть указано, какую строку показывать следующей - ее надо показывать даже если настройки текущего эффекта это запрещают
int8_t   sequenceIdx = -1;                  // Если нулевая строка массива содержит последовательность отображения строк (начинается с # или имеет значение ##) - указывает на позицию какой будет следующая отображаемая строка
int8_t   editIdx = -1;                      // Индекс строки, передаваемой в телефон на запрос строки по индексу
String   textWithEvents;                    // строка индексов текстовых строк, содержащих макрос {P} - то есть те, что требуют отслеживание момента времени
String   textsNotEmpty;                     // строка индексов текстовых строк, которые не пустые
#define  MAX_COLORS 6                       // сколько макросов цвета может содержать строка
int16_t  textColorPos[MAX_COLORS+1];        // Позиции начала цвета в строке
uint32_t textColor[MAX_COLORS+1];           // Цвета в строке
int8_t   preparedTextIdx = -1;              // Индекс строки, которая сейчас хранится в переменной preparedText;
String   preparedText;                      // Строка, которая была считана последним вызовом getTextByIdx();
int16_t  offset;                            // Смещение позиции отображения бегущей строки
bool     isPTextCentered;                   // Текущая бегущая строка содержит макрос {P} и флаг отображения остатка секунд по центру матрицы
bool     noCounterInText;                   // В бегущей строке с макросом {P} остатка секунд в тексте не отображать
int16_t  pTextCount;                        // Счетчик сколько раз уже отобразилась текущая строка с макросом {P}
int8_t   currentTimerEffectId = -1;         // Для какого эффекта установлен текущий таймер 

#if (USE_TEXT_CACHE == 1)
String   textLines[36];                     // Кэш хранения текстов бегущей строки в оперативной памяти
#endif

// --- 

uint32_t textStartTime = 0;                 // Время начала отображения текущей бегущей строки
uint32_t textLastTime = 0;                  // Время завершения отображения последней показанной бегущей строки
uint32_t textLastSend = 0;                  // Время последней отправки очередной строки списка строк в телефон
uint32_t textAllowBegin = 0;                // Для строк с макросом {S} - время начала допустимого интервала отображения unixTime
uint32_t textAllowEnd = 4294967295;         // Для строк с макросом {S} - время конца допустимого интервала отображения unixTime
String   textAllowWeekDays;                 // Для строк с макросом {S} - дни недели допустимого интервала отображения unixTime 

bool     loadingTextFlag = false;           // Флаг инициализации показа строки в режиме MC_TEXT (показ IP адреса); для новой строки оверлейного текста используется специальный вызов prepareNextText() в custom.ino
bool     showTextNow = false;               // флаг: что в настоящий момент нужно отображать оверлеем: true - оверлей бегущей строки; false - оверлей часов;
bool     fullTextFlag = false;              // флаг: текст бегущей строки показан полностью (строка убежала)
bool     gameOverFlag = false;              // флаг: демо-игра завершена

// --- 

typedef struct  {                           // Структура описателя событий постоянного контроля
  time_t moment;                            // unixtime - ближайший момент времени наступления события
  uint32_t before;                          // за сколько секунд до события начинать отображать строку
  uint32_t after;                           // сколько секунд после наступления события отображать строку-заместитель
  int8_t index_b;                           // индекс в виртуальном массиве строк отображаемой строки ДО события, привязанной к этому событию
  int8_t index_a;                           // индекс в виртуальном массиве строк отображаемой строки ПОСЛЕ события, привязанной к этому событию (-1 если строки замены не указано)
  bool   flagT;                             // Для макроса {P} - наличие флага #T, указывающий вывод обратного отсчета по центру
  bool   flagT2;                            // Для макроса {P} - то же, что и #T? только в строке вместо макроса {P} не выводится остаток строки - заменяется на постое
} Moment;

#define MOMENTS_NUM  6                      // максимальное количество отслеживаемых событий для строк, содержащих макрос {P}
Moment   moments[MOMENTS_NUM];              // массив с моментами времени событий для бегущих строк с макросом {P}
bool     moment_active = false;             // В текущий момент происходит отображение строки, привязанной к отслеживаемому событию.
int8_t   momentIdx = -1;                    // Индекс строки в виртуальном массиве moments для активного текущего непрерывно отслеживаемого события
int8_t   momentTextIdx = -1;                // Индекс строки в массиве moments[] для активного текущего непрерывно отслеживаемого события
uint32_t textCheckTime = 0;                 // Время контроля списка событий непрерывного отслеживания
bool     needRescanText = false;            // Флаг необходимости пересканировать события с макросом {P} чтобы определить время ближайшего события

// *************************** ПОДКЛЮЧЕНИЕ К СЕТИ **************************

                                            // к длине +1 байт на \0 - терминальный символ. Это буферы для загрузки имен/пароля из EEPROM. Значения задаются в define выше
uint8_t  IP_STA[]   = DEFAULT_IP;           // Статический адрес в локальной сети WiFi по умолчанию при первом запуске. Потом - загружается из настроек, сохраненных в EEPROM

// --------------------- WEB parameters -----------------

MDNSResponder mdns;

static const char BASE_WEB[] PROGMEM = "/web";         // префикс директории с статическими файлами веб-сервера
static const char DATA_WEB[] PROGMEM = "/web/assets";  // префикс директории с файлами данных, загружаемых с веб-сервера

AsyncWebServer server(80);                  // Web-сервер для управления через браузер
AsyncWebSocket ws("/ws");                   // Web-socket для коммуникации с Web-приложением

bool     web_ok = false;                    // Флаг - папка web найдена, значит, скорее всего WebUI загружена в файловую систему
int8_t   web_client_count = 0;              // Количество подключенных Web-клиентов;
int32_t  last_web_client_id;                // id последнего подключившегося клиента

#define  QSIZE_IN 24                        // размер очереди входящих команд от Web

String   cmdQueue[QSIZE_IN];                // кольцевой буфер очереди полученных команд от Web - команда
uint8_t  queueWriteIdx = 0;                 // позиция записи в очередь обработки полученных команд
uint8_t  queueReadIdx = 0;                  // позиция чтения из очереди обработки полученных команд
uint8_t  queueLength = 0;                   // количество команд в очереди обработки полученных команд

bool     isQueueInitialized = false;        // Массивы очереди входящих/исходящих сообщений инициализированы

String   changed_keys;                      // Строка, содержащая список измененных параметров, чье состояние требуется отправить серверу

#define  TOPIC_ERR      "err"               // Топик - отправка уведомлений об ошибке клиенту
#define  TOPIC_ALM      "alm"               // Топик - отправка клиенту сообщений о событиях будильника
#define  TOPIC_AMD      "amd"               // Топик - отправка клиенту сообщений о событиях авторежимов по времени
#define  TOPIC_WTR      "wtr"               // Топик - отправка клиенту сообщений о событиях погоды
#define  TOPIC_TXT      "txt"               // Топик - отправка клиенту сообщений о событиях бегущей строки
#define  TOPIC_STT      "stt"               // Топик - отправка клиенту сообщений о текущем статусе параметров устройства - основной набор параметров (пакет)
#define  TOPIC_SDC      "sdc"               // Топик - отправка клиенту сообщений о событиях SD-карты
#define  TOPIC_E131     "e131"              // Топик - отправка клиенту сообщений о событиях передачи данных по протоколу E131
#define  TOPIC_EDT      "edt"               // Топик - отправка параметров редактируемого эффекта в Web-интерфейс

// ---------------------------------------------------------------

bool     useSoftAP = false;                 // использовать режим точки доступа
bool     wifi_connected = false;            // true - подключение к wifi сети выполнена  
bool     ap_connected = false;              // true - работаем в режиме точки доступа;
bool     wifi_print_ip = false;             // Включен режим отображения текущего IP на индикаторе TM1637
bool     wifi_print_ip_text = false;        // Включен режим отображения текущего IP на матрице
bool     wifi_print_version = false;        // Включен режим отображения текущей версии прошивки
uint8_t  wifi_print_idx = 0;                // Индекс отображаемой на индикаторе TM1637 тетрады IP адреса
String   wifi_current_ip;                   // Отображаемый в бегущей строке IP адрес лампы

// **************** СИНХРОНИЗАЦИЯ ЧАСОВ ЧЕРЕЗ ИНТЕРНЕТ *******************

bool     init_time = false;                 // Флаг false - время не инициализировано; true - время инициализировано
bool     useNtp = true;                     // Использовать синхронизацию времени с NTP-сервером

// *************************** Yandex.Погода *****************************

bool     init_weather = false;              // Флаг: true - погода получена; false - погода не получена / не актуальна

#if (USE_WEATHER == 1)
  #define TRY_GET_WEATHER_CNT 2               // 2 попытки получить погоду. Если не удалось - отложить до следующего интервала
  uint8_t  useWeather = 1;                    // Использовать получение текущей погоды с погодного сервера 0 - не использовать; 1 - Yandex; 2 - OpenWeatherMap
  uint32_t regionID = WEATHER_REGION_YDX;     // Код региона по Yandex
  uint32_t regionID2 = WEATHER_REGION_OWM;    // Код региона по OpenWeatherMap
  String   skyColor;                          // Рекомендованный цвет фона погоды
  String   weather;                           // Состояние - "Ясно", "Облачно", "Дождь" и т.д.
  String   dayTime;                           // "Темное время суток" / "Светлое время суток"
  bool     isNight;                           // день / ночь
  bool     isFarenheit;                       // true - в Фаренгейтах, false - в Цельсиях
  int8_t   temperature;                       // Текущая температура 
  int16_t  weather_code;                      // код погодных условий для OpenWeatherMap

  String   icon;                              // код иконки, содержит зашифрованный статус погодных условий 
  uint32_t weather_t = 0;                     // Время, прошедшее с запроса данных с сервера погоды (таймаут)
  uint8_t  weather_cnt = 0;                   // Счетчик попыток получить данные от сервера
  uint32_t weather_time;                      // Время последнего получения погоды;
  uint8_t  weatherActualityDuration = 2;      // Какой период времени в часах после получения погоды считать ее актуальной (на случай, если сервер перестал отвечать)
  uint16_t SYNC_WEATHER_PERIOD = 30;          // Период обновления информации о текущей погоде в минутах по умолчанию
  uint8_t  refresh_weather = true;            // Флаг: пришло время очередного получения погоды с сервера
  bool     getWeatherInProgress = false;      // Запрос погоды сервера в процессе выполнения
  bool     weather_ok = true;                 // Погода получена

  // API-идентификатор сервиса получения погоды - смотрите раздел Wiki - Настройка получения информации о погоде
  // https://github.com/vvip-68/LedPanelWiFi/wiki/Настройка-получения-информации-о-погоде

  #ifndef  OWM_WEATHER_API_KEY
    // Ключ доступа к информации о погоде с сервиса OpenWeatherMap (зарегистрируйтесь на сервере https://openweathermap.org/api и получите свой ключ!)
    #define  OWM_WEATHER_API_KEY F("6a4ba421859c9f4166697758b68d889b")
  #endif

#endif

bool     useTemperatureColor = true;        // Для дневных часов: true - выводить температуру специальным цветом, в зависимости от значения температуры; 0 - не использовать градации цвета
bool     useTemperatureColorNight = false;  // Для ночных часов:  true - выводить температуру специальным цветом, в зависимости от значения температуры; 0 - не использовать градации цвета

#define  cold_less_30 0x3300FF             // -39..-30
#define  cold_29_20   0x0000FF             // -29..-20
#define  cold_19_10   0x0077FF             // -19..-10
#define  cold_9_4     0x00FFFF             //  -9..-4
#define  zero_3_3     0x808080             //  -3..+3
#define  hot_4_9      0xAA5511             //  +4..+9
#define  hot_10_19    0x773300             // +10..+19
#define  hot_20_29    0xA01F03             // +20..+29
#define  hot_30_great 0xFF0000             // +30..+39

// *********************** ДЛЯ БУДИЛЬНИКА-РАССВЕТ ************************

bool     isAlarming = false;                // Сработал будильник "рассвет"
bool     isPlayAlarmSound = false;          // Сработал настоящий будильник - играется звук будильника
bool     isAlarmStopped = false;            // Сработавший будильник "рассвет" остановлен пользователем
bool     isRemoteAlarm = false;             // Флаг - в режиме синхронизации на мастере сработал будильник
uint16_t auxLineModes = 0;                  // Текущая битовая маска режимов дополнительной линии питания по времени

uint8_t  alarmWeekDay = 0;                  // Битовая маска дней недели будильника
uint8_t  alarmDuration = 1;                 // Проигрывать звук будильнике N минут после срабатывания (по окончанию рассвета)

uint8_t  alarmHour[7]   = {0,0,0,0,0,0,0};  // Часы времени срабатывания будильника по дням недели
uint8_t  alarmMinute[7] = {0,0,0,0,0,0,0};  // Минуты времени срабатывания будильника по дням недели

int8_t   dawnHour = 0;                      // Часы времени начала рассвета
int8_t   dawnMinute = 0;                    // Минуты времени начала рассвета
uint8_t  dawnWeekDay = 0;                   // День недели времени начала рассвета (0 - выключено, 1..7 - пн..вс)
uint8_t  dawnDuration = 10;                 // Продолжительность "рассвета" по настройкам в минутах
uint8_t  realDawnDuration = 0;              // Продолжительность "рассвета" по вычисленному времени срабатывания будильника
uint8_t  alarmEffect = MC_DAWN_ALARM;       // Какой эффект используется для будильника "рассвет". Могут быть обычные эффекты - их яркость просто будет постепенно увеличиваться

// **************************** MP3 ПЛЕЕР *****************************

bool isDfPlayerOk = false;                  // MP3-Player корректно инициализирован и готов к использованию

#if (USE_MP3 == 1)

class    Mp3Notify;

// ESP8266
#if defined(ESP8266)
  // С аппаратными на этих чипах непонятки - используем программные
  #if (DFPLAYER_TYPE == 0)
    typedef  DFMiniMp3<SoftwareSerial, Mp3Notify, Mp3ChipOriginal> DfMp3;
  #else  // (DFPLAYER_TYPE == 1)
    typedef  DFMiniMp3<SoftwareSerial, Mp3Notify, Mp3ChipMH2024K16SS> DfMp3;
  #endif
  SoftwareSerial mp3Serial;
#else
  // ESP32 - используют HardwareSerial
  #if (DFPLAYER_TYPE == 0)
    typedef  DFMiniMp3<HardwareSerial, Mp3Notify, Mp3ChipOriginal> DfMp3;
  #else  // (DFPLAYER_TYPE == 1)
    typedef  DFMiniMp3<HardwareSerial, Mp3Notify, Mp3ChipMH2024K16SS> DfMp3;
  #endif
  #if (CONFIG_IDF_TARGET_ESP32)
    #define mp3Serial Serial2
  #else  
    #define mp3Serial Serial1
  #endif  
#endif

DfMp3    dfPlayer(mp3Serial);

int16_t  alarmSoundsCount = 0;              // Кол-во файлов звуков в папке '01' на SD-карте
int16_t  dawnSoundsCount = 0;               // Кол-во файлов звуков в папке '02' на SD-карте
int16_t  noteSoundsCount = 0;               // Кол-во файлов звуков в папке '03' на SD-карте
uint8_t  soundFolder = 0;                   // Текущая используемая папка со звуками 
uint8_t  soundFile = 0;                     // Текущий используемый файл звука в папке
int8_t   fadeSoundDirection = 1;            // направление изменения громкости звука: 1 - увеличение; -1 - уменьшение
uint8_t  fadeSoundStepCounter = 0;          // счетчик шагов изменения громкости, которое осталось сделать
bool     useAlarmSound = false;             // Использовать звуки в будильнике
int8_t   alarmSound = 0;                    // Звук будильника - номер файла в папке SD:/01 [-1 не использовать; 0 - случайный; 1..N] номер файла
int8_t   dawnSound = 0;                     // Звук рассвета   - номер файла в папке SD:/02 [-1 не использовать; 0 - случайный; 1..N] номер файла
int8_t   runTextSound = -1;                 // Номер звука в папке SD://03 на sd-карте, который нужно воспроизводить вместе с отображением бегущей строки
int8_t   playingTextSound = -1;             // Номер звука в папке SD://03 на sd-карте, который воспроизводится вместе с отображением бегущей строки
uint32_t runTextSoundTime;                  // Время, когда плеер закончил играть звук
bool     runTextSoundFirst = true;          // Флаг первого запуска проигрывания звука
bool     runTextSoundRepeat = false;        // Флаг - повторять в цикле: false - играть один раз; true - зацикливать
uint8_t  maxAlarmVolume = 30;               // Максимальная громкость будильника (1..30)
#endif

// ************************* КНОПКА УПРАВЛЕНИЯ *************************

#if (USE_BUTTON == 1)
  GButton  *butt;
  uint8_t  clicks = 0;
  uint32_t one_click_time;
  bool     clicks_printed = false;
#endif

#if (USE_BUTTON == 1 || USE_TM1637 == 1)
  uint8_t    bCounter = 0;                           // Счетчик нажатия на кнопку
  bool       isButtonHold = false;                   // Кнопка нажата и удерживается
#endif

// ************************** Дисплей TM1637 **************************

#if (USE_TM1637 == 1)
  TM1637Display *display;
  bool     aDirection = true;               // Направление счетчика изменения яркости, отображаемом на индикаторе при регулировке
  uint8_t  aCounter = 0;                    // Текущая яркость индикатора при плавном изменении яркости
  uint32_t fade_time;                       // Для плавного изменения яркости индикатора при сработавшем будильнике
  uint8_t  lastDisplay[4];                  // Содержимое вывода на индикатор TM1637 (последнее выведенное)
  uint8_t  currDisplay[4];                  // Содержимое вывода на индикатор TM1637 (подготовленное к выводу)
  uint8_t  lastDisplayBrightness;           // Текушая яркость дисплея (последнее примененное значение 
  uint8_t  currDisplayBrightness;           // Яркость дисплея, которую требуется установить
  bool     lastDotState;                    // Текущее (последнее установленное) состояние точки на дисплее
  bool     currDotState;                    // Новое состояние точки на дисплее, которое требуется показать
#endif

// ******************** ВКЛЮЧЕНИЕ РЕЖИМОВ ПО ВРЕМЕНИ *********************

bool     AM1_running = false;               // Режим 1 по времени - работает
uint8_t  AM1_hour = 0;                      // Режим 1 по времени - часы
uint8_t  AM1_minute = 0;                    // Режим 1 по времени - минуты
int8_t   AM1_effect_id = -3;                // Режим 1 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM2_running = false;               // Режим 2 по времени - работает
uint8_t  AM2_hour = 0;                      // Режим 2 по времени - часы
uint8_t  AM2_minute = 0;                    // Режим 2 по времени - минуты
int8_t   AM2_effect_id = -3;                // Режим 2 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM3_running = false;               // Режим 3 по времени - работает
uint8_t  AM3_hour = 0;                      // Режим 3 по времени - часы
uint8_t  AM3_minute = 0;                    // Режим 3 по времени - минуты
int8_t   AM3_effect_id = -3;                // Режим 3 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM4_running = false;               // Режим 4 по времени - работает
uint8_t  AM4_hour = 0;                      // Режим 4 по времени - часы
uint8_t  AM4_minute = 0;                    // Режим 4 по времени - минуты
int8_t   AM4_effect_id = -3;                // Режим 4 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     dawn_running = false;              // Режим по времени "Рассвет" - работает
uint8_t  dawn_hour = 0;                     // Режим по времени "Рассвет" - часы
uint8_t  dawn_minute = 0;                   // Режим по времени "Рассвет" - минуты
int8_t   dawn_effect_id = -3;               // Режим по времени "Рассвет" - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     dusk_running = false;              // Режим по времени "Закат" - работает
uint8_t  dusk_hour = 0;                     // Режим по времени "Закат" - часы
uint8_t  dusk_minute = 0;                   // Режим по времени "Закат" - минуты
int8_t   dusk_effect_id = -3;               // Режим по времени "Закат" - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST

// ************************* РАБОТА С SD КАРТОЙ *************************

#if (USE_SD == 1)

#define  MAX_FILES 126                      // больше нельзя - переполнение индекса массива для типа int8_t -128..127; Значение 127 и < 0 - специальные значения для перехода по циклу эффектов

String   nameFiles[MAX_FILES];              // Список имен файлов, найденных в папке на SD-карте
bool     isSdCardExist = false;             // Флаг - SD карта инициализирована корректно (присутствует в системе)
bool     isSdCardReady = false;             // Флаг - на SD карте найдены файлы эффектов
bool     play_file_finished = false;        // Флаг - воспроизведение эффекта завершено
uint8_t  countFiles = 0;                    // Количество найденных файлов эффектов, найденных на SD-карте
int8_t   sf_file_idx = -1;                  // Эффект, проигрываемый с SD-карты - индекс в массиве nameFiles
bool     sd_card_ok = false;

#endif


// ************************* ПРОЧИЕ ПЕРЕМЕННЫЕ *************************

#define  D_GAME_SPEED        150            // скорость игр по умолчанию (мс)
#define  D_EFFECT_SPEED       80            // скорость эффектов по умолчанию (мс)
#define  D_EFFECT_SPEED_MIN    0            // пределы регулировки скорости
#define  D_EFFECT_SPEED_MAX  255

// ---------------------------------------------------------------

#define  AUTOPLAY_PERIOD      30            // время между авто сменой режимов (секунды)
#define  IDLE_TIME            10            // время бездействия (в минутах, по умолчанию) после которого запускается автосмена режимов, если разрешена в настройках

// ---------------------------------------------------------------

uint8_t  eeprom_id = 0;                     // Текущая версия EEPROM
bool     isEEPROMInitialized = false;       // EEPROM мнициализирован и содержит корректные данные
bool     eepromModified = false;            // флаг: EEPROM изменен, требует сохранения

// ---------------------------------------------------------------

uint32_t globalColor      = 0xffffff;       // цвет панели в режиме "Лампа" по умолчанию
uint32_t globalClockColor = 0xffffff;       // цвет часов в режиме MC_COLOR - режим цвета "Монохром" по умолчанию
uint32_t globalTextColor  = 0xffffff;       // цвет бегущей строки MC_TEXT в режиме цвета "Монохром" по умолчанию
uint32_t drawColor        = 0xffffff;       // цвет рисования

// ---------------------------------------------------------------

bool     specialMode = false;               // Спец.режим, включенный вручную со смартфона или с кнопок быстрого включения режима
bool     specialClock = false;              // Отображение часов в спец.режиме - как отдельный эффект "Часы" на черном фоне, а не как оверлей поверх других эффектов
uint8_t  specialBrightness = 1;             // Яркость в спец.режиме

bool     isTurnedOff = false;               // Включен черный экран (т.е. всё выключено)
bool     isNightClock = false;              // Включен режим ночных часов
bool     isAuxActive = false;               // Линия дополнительного управления питанием активна (включена на локальной машине)
bool     isRemoteAuxActive = false;         // Линия дополнительного управления питанием активна (включена на мастере, получена по вещанию)

int8_t   specialModeId = -1;                // Номер текущего спецрежима

bool     useRandomSequence = true;          // Флаг: случайный выбор режима
bool     clockOverlayEnabled = true;        // Доступность оверлея часов поверх эффектов
bool     textOverlayEnabled = true;         // Доступность оверлея бегущей строки поверх эффектов
int8_t   text_overlay_low  = 0;             // Вычисленная позиция оверлея матрицы - во всю ширину, область отображения текста бегущей строки - в процессе вычислении могут получаться отрицательные значения
int8_t   text_overlay_high = 0;

int8_t   clockOffsetX = 0;                  // Смещение часов относительно центра (коррекция положения по оси X)  
int8_t   clockOffsetY = 0;                  // Смещение часов относительно центра (коррекция положения по оси Y)  
uint8_t  clockDotWidth = 2;                 // Ширина разделительных точек в больших часах 1 или 2, если позволяет ширина маирицы
bool     clockDotSpace = true;              // Точки в больших часах отделены от цифр пробелом (если позволяет ширина матрицы)

// ---------------------------------------------------------------

#if (USE_ANIMATION == 1)
String   animations_list;                   // Список найденных анимаций для эффекта "Анимация"
#endif

// ---------------------------------------------------------------

uint8_t  globalBrightness = BRIGHTNESS;     // текущая яркость бегущей строки и часов (общая)
uint8_t  contrast = 255;                    // контрастность эффектов по отношению к яркости часов / бегущей строки (общей яркости) => 0.255 -> 10..100%
bool     brightDirection = false;           // true - увеличение яркости; false - уменьшение яркости при регулировке кнопкой

// ---------------------------------------------------------------

uint8_t  effectScaleParam[MAX_EFFECT_SUPPORT];  // Динамический параметр эффекта - параметр #1
uint8_t  effectScaleParam2[MAX_EFFECT_SUPPORT]; // Динамический параметр эффекта - параметр #2
uint8_t  effectContrast[MAX_EFFECT_SUPPORT];    // Динамический параметр эффекта - контрастность (яркость эффекта относительно яркости часов или текста бегущей строки)
uint8_t  effectSpeed[MAX_EFFECT_SUPPORT];       // Динамический параметр эффекта - скорость
bool     manualMode = false;                    // флаг: true - ручное управление эффектами; false - в режиме Autoplay
bool     loadingFlag = true;                    // флаг: инициализация параметров эффекта

// ---------------------------------------------------------------

uint32_t idleTime = ((uint32_t)IDLE_TIME * 60 * 1000UL);      // минуты -> миллисекунды
uint32_t autoplayTime = ((uint32_t)AUTOPLAY_PERIOD * 1000UL); // секунды -> миллисекунды
uint32_t autoplayTimer;                                       // время до автоматического перехода в демо-режим
uint32_t upTime = 0;                                          // время работы системы с последней перезагрузки

// ---------------------------------------------------------------

int8_t   thisMode = 0;                      // текущий режим - id
String   effect_name;                       // текущий режим - название

// ---------------------------------------------------------------

#define  GLOBAL_COLOR_1 CRGB::Green         // основной цвет №1 для игр
#define  GLOBAL_COLOR_2 CRGB::Orange        // основной цвет №2 для игр
#define  SCORE_SIZE 1                       // размер символов счёта в игре. 0 - маленький для 8х8 (шрифт 3х5), 1 - большой (шрифт 5х7)

bool     gameDemo = true;                   // Игры Тетрис, Лабиринт, Змейка работают в демо-режиме
bool     gamePaused = false;                // Игра на паузе (при ручном управлении игрой) 
uint8_t  buttons;                           // Эмуляция кнопок управления играми в демо-режиме

// ---------------------------------------------------------------

timerMinim gameTimer(D_GAME_SPEED);         // Таймер скорости игр
timerMinim effectTimer(D_EFFECT_SPEED);     // Таймер скорости эффекта (шага выполнения эффекта)
timerMinim clockTimer(D_CLOCK_SPEED);       // Таймер смещения оверлея часов
timerMinim textTimer(D_TEXT_SPEED);         // Таймер смещения оверлея часов
timerMinim halfsecTimer(500);               // Полусекундный таймер точек часов
timerMinim idleTimer(idleTime);             // Таймер бездействия ручного управления для автоперехода в демо-режим 
timerMinim dawnTimer(1000);                 // Таймер шага рассвета для будильника "рассвет" 
timerMinim alarmSoundTimer(4294967295);     // Таймер выключения звука будильника
timerMinim fadeSoundTimer(4294967295);      // Таймер плавного включения / выключения звука
timerMinim saveSettingsTimer(15000);        // Таймер отложенного сохранения настроек

#if (USE_WEATHER == 1)
timerMinim weatherTimer(1000 * 60 * SYNC_WEATHER_PERIOD); // Получаем текущую погоду каждые SYNC_WEATHER_PERIOD минут
#endif

// ********************* ДЛЯ ПАРСЕРА КОМАНДНЫХ ПАКЕТОВ *************************

#define    PARSE_AMOUNT  16                 // максимальное количество значений в массиве, который хотим получить 
int32_t    intData[PARSE_AMOUNT];           // массив численных значений после парсинга - для WiFi часы время синхронизации может быть отрицательным +
                                            // период синхронизации может быть больше 255 мин - нужен тип int32_t

// **************** ДЛЯ СИНХРОННОЙ РАБОТЫ УСТРОЙСТВ И ПРИЕМА ПОТОКА E1.31 ******************

#if (USE_E131 == 1)

ESPAsyncE131 *e131;                         // Объект приемника данных по протоколу E1.31 в UDP пакетах по WiFi
e131_packet_t *e131_packet;                 // Пакет данных формата E1.31

// Режимы работы панели - Самостоятельный без поддержки синхронизации, Мастер (ведущий), Слушатель (подчиненный)
enum  eWorkModes   {
  STANDALONE, 
  MASTER, 
  SLAVE
} workMode, prevWorkMode; 

// Режим синхронизации
enum  eSyncModes   {                        // Данные в E1.31 пакете  
  PHYSIC,                                   // соответствуют физическому порядку следования диодов в цепочке соединения матрицы (самый быстрый)
  LOGIC,                                    // соответствуют логическому порядку, начиная с левого верхнего угла X,Y=0,0, далее вправо по X? затем вниз по Y (медленный, но позволяет правильно работать устройствам с разным типом подключения и размером матриц)  
  COMMAND                                   // пакет не содержит данных RGB светодиодов. Мастер отправляет ведомым команды на включение того или иного режима, которые ведомые устройства обрабатывают самостоятельно.
} syncMode, prevSyncMode;

#define    MAX_UNIVERCE_COUNT 12            // Сколько вселенных выделено на одну группу 12 * 170 = 2040 диодов в группе
uint16_t   START_UNIVERSE = 1;              // Номер начальной вселенной для прослушивания E1.31 (DMX) пакетов
uint8_t    UNIVERSE_COUNT = 2;              // Общее количество прослушиваемых вселенных; Одна вселенная - 170 диодов. Для матрицы 16x16 достаточно двух вселенных
uint16_t   END_UNIVERSE = 2;                // Номер конечной вселенной

uint8_t    syncGroup = 0, prevSyncGroup;    // Номер группы синхронизации (одна группа может содержать до 7 вселенных (по протоколу управления E1.31 DMX MULTICAST), т.е для Группы 0 - 1..12 вселенные, для Группы 1 - 13..24 вселенные и т.д.
uint32_t   e131_last_packet;                // Время поступления последнего E1.31 пакета.
uint8_t    e131_send_delay = 0;             // Задержка миллисекунд после отправки данных мастером в канал E1.31 и до отображения сформированных данных на стороне мастера на матрицу - для визуальной синхронизации панелей MASTER-SLAVE
uint8_t    e131_cid[16];                    // Идентификатор устройства для отправки пакета мастером по протоколу E1.31

uint16_t   frameCnt = 0;                    // Количество принятых фреймов по потоку E1.31 за интервал времени
uint32_t   last_fps_time = 0;               // Последнее время отображения / расчета FPS потока
                             
                                            // В режиме синхронизации SLAVE / COMMAND
uint8_t    syncEffectSpeed;                 // Скорость эффекта
uint8_t    syncEffectContrast;              // Контраст эффекта 
uint8_t    syncEffectParam1;                // Параметр эффекта 1
uint8_t    syncEffectParam2;                // Параметр эффекта 2

uint8_t    masterWidth;                     // ширина матрицы MASTER устройства при получении пакета синхронизации
uint8_t    masterHeight;                    // высота матрицы MASTER устройства при получении пакета синхронизации

int8_t     masterX = 0, masterY = 0;        // (X,Y) - левый верхний угол окна МАСТЕРА (режим LOGIC) - откуда начинается трансляция изображения с мастера на этом устройстве
int8_t     localX = 0, localY = 0;          // (X,Y) - левый верхний угол окна локальной матрицы, куда начинается вывод трансляции на это устройство изображения с мастера
int8_t     localW = 0, localH = 0;          // ширина и высота окна локальной матрицы, куда ведется трансляция на этом устройстве изображения с мастера

#define    E131_FPS_INTERVAL  10000         // Отображать FPS получаемого потока каждые 10000 мс (10 сек); Установите 0  если отображать не нужно;
#define    E131_TIMEOUT  2000               // Таймаут в миллисекундах получения потока E1.31. Если данных нет - переключаемся на самостоятельную работу

#endif

bool       streaming = false;               // В настоящее время идет передача (MASTER) или прием (SLAVE) пакетов E1.31
bool       e131_streaming = false;          // Устройство работает в режиме отправки E1.31 пакетов (MASTER) или происходит прием E1.31 пакетов (SLAVE)
bool       e131_wait_command = false;       // Устройство работает в режиме прием E1.31 пакетов команд (SLAVE, COMMAND)

// ************************* УПРАВЛЕНИЕ МАТРИЦЕЙ *******************************

String     host_name;                            // Имя для регистрации в сети
uint16_t   CURRENT_LIMIT = 10000;                // лимит по току в миллиамперах, автоматически управляет яркостью (пожалей свой блок питания!) 0 - выключить лимит

uint8_t    mapWIDTH = WIDTH;                     // полная ширина ширина матрицы 1..128 при использовании карты индексов
uint8_t    mapHEIGHT = HEIGHT;                   // полная высота матрицы 1..128 при использовании карты индексов

uint8_t    sWIDTH = WIDTH;                       // ширина одного сегмента матрицы 1..128
uint8_t    sHEIGHT = HEIGHT;                     // высота одного сегмента матрицы 1..128
uint8_t    sMATRIX_TYPE = MATRIX_TYPE;           // тип соединения диодов в сегменте матрицы: 0 - зигзаг, 1 - параллельная, 2 - карта индексов
uint8_t    sCONNECTION_ANGLE = CONNECTION_ANGLE; // угол подключения диодов в сегменте: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний
uint8_t    sSTRIP_DIRECTION = STRIP_DIRECTION;   // направление ленты из угла сегмента: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз

uint8_t    mWIDTH = META_MATRIX_WIDTH;           // количество сегментов в ширину 1..9
uint8_t    mHEIGHT = META_MATRIX_HEIGHT;         // количество сегментов в высоту 1..9
uint8_t    mTYPE = META_MATRIX_TYPE;             // соединение сегментов мета-матрицы: 0 - зигзаг, 1 - параллельная
uint8_t    mANGLE = META_MATRIX_ANGLE;           // угол 1-го сегмента мета-матрицы: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний
uint8_t    mDIRECTION = META_MATRIX_DIRECTION;   // направление следующих сегментов мета-матрицы из угла: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз

uint8_t    pWIDTH = sWIDTH * mWIDTH;
uint8_t    pHEIGHT = sHEIGHT * mHEIGHT;

uint16_t   NUM_LEDS = pWIDTH * pHEIGHT;
uint8_t    maxDim   = max(pWIDTH, pHEIGHT);
uint8_t    minDim   = min(pWIDTH, pHEIGHT);

#define    MAX_MAP_FILES 5                       // Один файл карты индексов - одно разрешение WxH матрицы
String     mapFiles[MAX_MAP_FILES];              // Список имен файлов карт индексов, найденных в корне файловой системы
uint8_t    mapListLen = 0;

struct CRGB *leds = nullptr;                     // обращение к светодиодам матрицы через этот массив
struct CRGB *overlayClock = nullptr;             // буфер оверлея часов
struct CRGB *overlayCalendar = nullptr;          // буфер оверлея календаря
struct CRGB *overlayTemperature = nullptr;       // буфер оверлея температуры
struct CRGB *overlayText = nullptr;              // буфер оверлея текста

#define    TRUE_RANDOM

#ifndef    DEBUG_MEM_EFF
#define    DEBUG_MEM_EFF 0                       // Вкл/выкл вывод отладочных сообщений об объеме свободной памяти при смене эффектов
#endif

#ifndef    DEBUG_MEM_STP
#define    DEBUG_MEM_STP 0                       // Вкл/выкл вывод отладочных сообщений об объеме свободной памяти при каждой итерации цикла loop()
#endif

// *****************************************************************************

  bool    vDEBUG_SERIAL;                         // Включен ли отладочный вывод
  uint8_t vDEVICE_TYPE;                          // Тип использования матрицы устройства: 0 - матрица в трубу (лампа); 1 - плоская
  uint8_t vBUTTON_TYPE;                          // Тип кнопки, если родключено: 0 - сенсорная 1 - тактовая
  bool    vWAIT_PLAY_FINISHED;                   // Когда переключаться на следующий эффект после показа ролика с SD-карты
  bool    vREPEAT_PLAY;                          // Когда переключаться на следующий эффект после показа ролика с SD-карты
  
  uint8_t vPOWER_ON;                             // Уровень сигнала на реле для включения HIGH (0x01) или LOW (0x00)  - линия управления пимтанием матрицы
  uint8_t vPOWER_OFF;                            // Уровень сигнала на реле для вЫключения HIGH (0x01) или LOW (0x00)
  int8_t  vPOWER_PIN;                            // Пин управления реле

  uint8_t vALARM_ON;                             // Уровень сигнала на реле для включения HIGH (0x01) или LOW (0x00)  - линия будильника
  uint8_t vALARM_OFF;                            // Уровень сигнала на реле для вЫключения HIGH (0x01) или LOW (0x00)
  int8_t  vALARM_PIN;                            // Пин управления реле

  uint8_t vAUX_ON;                               // Уровень сигнала на реле для включения HIGH (0x01) или LOW (0x00)  - линия дополнительного управления
  uint8_t vAUX_OFF;                              // Уровень сигнала на реле для вЫключения HIGH (0x01) или LOW (0x00)
  int8_t  vAUX_PIN;                              // Пин управления реле

// *****************************************************************************

// ---------------- ДЛЯ ЭФФЕКТА "КАРТИНКИ" (СЛАЙДЫ) --------------

String     pictureStorage;                       // "SD" - на карте памяти или "FS" - в файловой системе контроллера или "" - из внктреннего эффекта "Погода"
uint8_t    pictureWidth;                         // Ширина картинок (слайдов)
uint8_t    pictureHeight;                        // Высота картинок (слайдов)
String     pictureList;                          // Строка имен файлов картинок, разделенных запятыми, если они найдены в файловой системе SD или FS
uint8_t    pictureIndexMax;                      // Количество найденных картинок, пригодных к использованию
uint8_t    pictureIndex;                         // Индекс в массиве pictureList - текущий слайд
uint8_t    weatherIndex;                         // Индекс анимации "Погода"

// ------------------ ФАЙЛОВАЯ СИСТЕМА SPIFFS --------------------

bool       spiffs_ok = false;                    // Флаг - файловая система SPIFFS доступна для использования
size_t     spiffs_total_bytes;                   // Доступно байт в SPIFFS
size_t     spiffs_used_bytes;                    // Использовано байт в SPIFFS
int8_t     eeprom_backup = 0;                    // Флаг - backup настроек 0 - нeт; 1 - FS; 2 - SD; 3 - FS и SD

// ------------------- ВРЕМЕННЫЕ ПЕРЕМЕННЫЕ ----------------------

bool       saveSpecialMode;
int8_t     saveSpecialModeId;
uint8_t    saveMode;
bool       saveManualMode;
uint8_t    tmpSaveMode = 0;
uint8_t    resourcesMode = 0;
bool       mandatoryStopText = false;
bool       needRestart = false;
uint32_t   needRestartTime = 0;  

bool       use_round_3x5 = false;                // В малых часах - скругленный шрифт
uint8_t    clockW, clockH;                       // Ширина и высота блока отображения часов (зависит от текущего времени из за разной ширины цифр текушего времени)
int8_t     clockX, clockY;                       // Левый нижний угол блока текущего отображения часов
int8_t     clockX_H10_pos, clockX_H01_pos;       // Позиция отображения десятков/единиц часов и минут относительно двоеточия разделителя времени
int8_t     clockX_M10_pos, clockX_M01_pos;    
int8_t     clockY_H10_pos, clockY_H01_pos;    
int8_t     clockY_M10_pos, clockY_M01_pos;    
int8_t     clockX_dot_pos;
bool       show_clockH10_zero;                   // Показывать ли десятки часов, если они 0

#if (USE_WEATHER == 1)      
uint8_t    temperatureW, temperatureH;           // Ширина и высота блока отображения часов (зависит от текущего времени из за разной ширины цифр текушего времени)
int8_t     temperatureX, temperatureY;           // Левый нижний угол блока текущего отображения часов
int8_t     temperatureX_T10_pos, temperatureX_T01_pos;
int8_t     temperatureX_SG_pos,  temperatureX_DG_pos;
int8_t     temperatureX_CF_pos;
bool       show_tempCF = false;                  // Показывать ли C/F в малых часах
bool       show_tempDG = false;                  // Показывать ли знак градуса в малых часах (если включен прказ C/F)
bool       showTempDegree = false;               // Температура в часах - true - рисовать значок градуса, false - не рисовать
bool       showTempLetter = false;               // Температура в часах - true - рисовать C/F, 1 - не рисовать C/F
bool       showTempTextDegree = true;            // Температура макросе {WT} - true - рисовать значок градуса, false - не рисовать
bool       showTempTextLetter = true;            // Температура макросе {WT} - true - рисовать C/F, 1 - не рисовать C/F
#endif

uint8_t    calendarW, calendarH;                 // Ширина и высота блока отображения календаря (зависит от текущей даты из за разной ширины цифр текушей даты)
int8_t     calendarX, calendarY;                 // Левый нижний угол блока текущего отображения календаря
int8_t     calendarX_DT_pos;
int8_t     calendarX_D10_pos,   calendarX_D01_pos;
int8_t     calendarX_M10_pos,   calendarX_M01_pos;    
int8_t     calendarX_Y1000_pos, calendarX_Y0100_pos;    
int8_t     calendarX_Y0010_pos, calendarX_Y0001_pos;    
int8_t     calendarY_D10_pos,   calendarY_D01_pos;
int8_t     calendarY_M10_pos,   calendarY_M01_pos;    
int8_t     calendarY_Y1000_pos, calendarY_Y0100_pos;    
int8_t     calendarY_Y0010_pos, calendarY_Y0001_pos;    

unsigned long prevSendTimer = 0;
unsigned long prevShowTimer = 0;

#if (USE_POWER == 1)
uint8_t line_power_state = 2;                    // Текущее состояние линии управления питанием 0/1 - знАчимые вкл/выкл); 2 - не определено.
#endif
#if (USE_ALARM == 1)
uint8_t line_alarm_state = 2;                    // Текущее состояние линии управления alarm 0/1 - знАчимые вкл/выкл); 2 - не определено.
#endif
#if (USE_AUX == 1)
uint8_t line_aux_state = 2;                      // Текущее состояние линии управления aux 0/1 - знАчимые вкл/выкл); 2 - не определено.
#endif

// --------------------- Для работы с JSON -----------------------

#if defined(ESP32)
#define MAX_BUFFER_SIZE 2048                     // Максимальный размер сформированного JSON для отправки данных клиенту в WEB-браузер 
#else
#define MAX_BUFFER_SIZE 512                      // Максимальный размер сформированного JSON для отправки данных клиенту в WEB-браузер 
#endif

DynamicJsonDocument doc(MAX_BUFFER_SIZE);        // Объект сериализует структуру с данными, которые будут отправлены клиенту 

// ----------------- ОБЩИЕ ПЕРЕМЕННЫЕ ЭФФЕКТОВ -------------------

uint8_t    phase = 0;                            // фаза эффекта
uint8_t    hue;
int16_t    loopCounter;
int16_t    loopCounter2;
uint32_t   lastMillis;
uint32_t   lastMillisX;
uint32_t   lastMillisY;

static const char DELIM_LINE[] PROGMEM = "-------------------------------------------";

static const char MIMETYPE_HTML[] PROGMEM = "text/html";
    
static const char sE131[]    PROGMEM = "E131";
static const char sMASTER[]  PROGMEM = "MASTER"; 
static const char sSLAVE[]   PROGMEM = "SLAVE";
static const char sPHYSIC[]  PROGMEM = "PHYSIC";
static const char sLOGIC[]   PROGMEM = "LOGIC";
static const char sCOMMAND[] PROGMEM = "COMMAND";

static const char sTIMEOUT[] PROGMEM = "TIMEOUT";
static const char sWEATHER[] PROGMEM = "WEATHER";

static const char sFL[]  PROGMEM = "L>";
static const char sFC[]  PROGMEM = "C>";

// ------------------- КОМАНДЫ СИНХРОНИЗАЦИИ E131 -------------------

#define CMD_TURNONOFF       0
#define CMD_BRIGHTNESS      1
#define CMD_SPCBRIGHTNESS   2
#define CMD_EFFECT          3
#define CMD_SPCEFFECT       4
#define CMD_RUNTEXT         5
#define CMD_STOPTEXT        6
#define CMD_TIME            7
#define CMD_SPEED           8
#define CMD_CONTRAST        9
#define CMD_PARAM1         10
#define CMD_PARAM2         11
#define CMD_COLOR          12
#define CMD_DIMENSION      13
#define CMD_TEXTSPEED      14
#define CMD_CLOCKSPEED     15
#define CMD_CURBRIGHTNESS  16
#define CMD_AUXACTIVE      17
#define CMD_ALARMING       18
