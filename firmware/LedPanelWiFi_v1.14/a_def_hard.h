// ****************** ПРОФИЛИ УСТРОЙСТВ *******************
//
// ВНИМАНИЕ!!! 
// Рекомендации по выбору ядра для ESP32 и ESP8266 и платы для сборки в настройках Arduino IDE смотри в комментариях в начале основного файла скетча.
//
// --------------------------------------------------------

#define HOST_NAME  F("WiFiPanel")

#define LANG  'RUS'           // Определение языка параметров, передаваемых в приложение управления или Web-интерфейс 'RUS','ENG' или другой, определенный в файле a_def_lang.h
                              // Доступные языки смотри в файле a_def_lang.h; Можете при необходимости там же добавить свой язык

#define A_DEF_DEVC 1          /* 1 - Настройки профилей ваших устройств вынесены в отдельный файл "a_def_devc.h" */
                              // 0 - Настройки профиля вашего устройства размещены ниже в этом файле
                              // Файл "a_def_devc.h" в комплект не входит, нужно создать, скопировать туда настройки профилей ваших устройств
                              // Пример содержимого файла можно взять из архива public.zip и использовать его в качестве шаблона, изменив настройки в нем
                              
#define A_DEF_PASS 1          /* 1 - Настройки API KEY OpenWeatherMap в отдельном файле a_def_pass.h */
                              // 0 - Настройки API KEY OpenWeatherMap определен ниже
                              // Файл a_def_pass.h в комплект не входит, нужно создать, скопировать туда указанные строки
                              // Пример содержимого файла можно взять из архива public.zip и использовать его в качестве шаблона, изменив настройки в нем

#define INITIALIZE_TEXTS 1    /* Заполнить память текстов бегущей строки текстом из примеров при первичной загрузке прошивки или при смене значения EEPROM_OK, когда */
                              // все настройки сбрасываются в значения по-умолчанию
#define TEXT_SHIFT 1          /* На сколько колонок сдвигать бегущую строку за один раз. По умолчанию - на одну колонку */
                              // Скорость сдвига строки зависит от скорости вывода картинки на матьрицу. На больших матрицах требуется больше времени на вывод одного кадра
                              // Если вам кажется что на максимальной скорости строка все равно движется медленно - укажите параметр TEXT_SHIFT равным 2 мли 3. 
                              // Тогда каждый сдвиг текста будет выполняться сразу на 2 или три колонки. Текст будет двигаться быстрее, но визуально менее плавно

#define USE_TEXT_CACHE 1      // Держать тексты бегущей строки в оперативной памяти (по возможности). 
                              // Кэширование строк в памяти позволит свести к нулю время получения очередной строки для отображения
                              // Загрузка строки из файла требует некоторого времени, что вызывает торможение отображение эффекта перед показом бегущей строки
                              // Однако кэш в памяти уменьшает объем свободной оперативной памяти, что на устройствах с ESP8266 может приводить к частым 
                              // перезагрузкам микроконтроллера при нехватки памяти. Тогда установите значение этого параметра в 0 - не использовать
#if defined(ESP8266)
#define TEXT_CACHE_LINE_SIZE 200   // Макс длина текста бегущей строки, которая будет кэшироваться. Более длинные строки будут по-прежнему загружаться перед использованием из файла
#else
#define TEXT_CACHE_LINE_SIZE 512   // Макс длина текста бегущей строки, которая будет кэшироваться. Более длинные строки будут по-прежнему загружаться перед использованием из файла
#endif

                              

// Варианты профилей для устройства, выполненного на микроконтроллере ESP8266 (NodeMCU, Wemos d1 mini, ...)

#if defined(ESP8266)
#define DEVICE_VARIANT 0      /* Поставьте 0 - если ваше устройство использует только часть из доступных компонентов в схемах с ESP8266 - не полная схема */
                              // Поставьте 1 - если ваше устройство ИСПОЛЬЗУЕТ ВСЕ ВОЗМОЖНЫЕ К ПОДКЛЮЧЕНИЮ компоненты (кнопка, DFPlayer, SD-card, TM1637, управление питанием) - полная схема
                              // Для варианта DEVICE_VARIANT == 1 обязательно должен быть отключен отладочный вывод в Serial, поскольку пины контроллера, связанные с
                              // отладочным выводом (D9 и D10 / RX и TX) заняты под подключение компонент кнопки и индикатора TM1637
                              
                              // Обратите внимание - пины подключения для DEVICE_VARIANT == 0 и DEVICE_VARIANT == 1 - отличаются
                              // Выполняйте сборку устройства в соответственно с выбранной схемой
                              //
                              // При необходимости измените настройки подключении в соответсвии с вариантом вашего устройства:
                              //   для DEVICE_VARIANT == 0 --> строки 135-284
                              //   для DEVICE_VARIANT == 1 --> строки 286-414
#endif

// ===================================================================
// Если вы собираете матрицу из ленты светодиодов или ОДНОЙ готовой заводской матрицы 8x8, 16x16 или 8x32 -,
// укажите ниже в параметрах WIDTH, HEIGHT, MATRIX_TYPE, CONNECTION_ANGLE и STRIP_DIRECTION значения,
// описывающие размеры вашей матрицы, её тип (змейка / параллельная) и угол подключения.
//
// В параметры META_MATRIX_WIDTH и META_MATRIX_HEIGHT поставьте 1 (матрица состоит из одного сегмента),
// параметры META_MATRIX_TYPE, META_MATRIX_ANGLE, META_MATRIX_DIRECTION не имеют значения

// Если у вас в наличии несколько заводских матриц 8x8, 16x16 или 8x32 и вы из них собираете одну большую сборную матрицу:
//
// MATRIX_TYPE == 0 или MATRIX_TYPE == 1
// 
//   Для сборной матрицы из сегментов одинакового размера и возможности их одинаковой ориентации (угол подключения и направление из угла)
//   укажите ниже в параметрах WIDTH, HEIGHT, MATRIX_TYPE, CONNECTION_ANGLE и STRIP_DIRECTION значения,
//   описывающие размеры, тип и угол подключения ОДНОГО СЕГМЕНТА вашей заводской матрицы.
//
//   WIDTH                   - ширина одной заводской матрицы - одного сегмента
//   HEIGHT                  - высота одной заводской матрицы - одного сегмента
//   MATRIX_TYPE             - тип соединения диодов в сегменте матрицы: 0 - зигзаг, 1 - параллельная
//   CONNECTION_ANGLE        - угол подключения диодов в сегменте: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний
//   STRIP_DIRECTION         - направление ленты из угла сегмента: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз
//   MATRIX_INDEX            - не используется
//
//   META_MATRIX_WIDTH       - количество сегментов (заводских матриц) в ширину сборной матрицы
//   META_MATRIX_HEIGHT      - количество сегментов (заводских матриц) в высоту сборной матрицы
//   META_MATRIX_TYPE        - тип сборной матрицы: 0 - зигзаг, 1 - параллельная
//   META_MATRIX_ANGLE       - угол 1-го сегмента сборной матрицы: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний
//   META_MATRIX_DIRECTION   - направление следующих сегментов сборной матрицы из угла: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз
// 
//   Все сегменты (заводские матрицы) из которых собрана ваша сборная матрица должны быть одного размера и ориентированы 
//   одинаково по углу подключения и направлению диодов из угла,как описано в параметрах MATRIX_TYPE, CONNECTION_ANGLE и STRIP_DIRECTION.
//   Сами сегменты (заводские матрицы) подключены по типу параллельного подключения или змейкой, последовательность соединения сегментов - 
//   в соответствии с указанными параметрами META_MATRIX_TYPE, META_MATRIX_ANGLE, META_MATRIX_DIRECTION, которые имеют значения, по смыслу такие же, 
//   как для подключения диодов в одной заводской матрице (MATRIX_TYPE, CONNECTION_ANGLE и STRIP_DIRECTION).
//
// MATRIX_TYPE == 2
//
//   Если ваша сборная матрица состоит из матриц различного размера (смесь разных матриц) или нет возможности сориентировать все
//   элементарные матрицы одинаково ао углу подключения и направлению из угла (ввиду длинных проводов для их соединения иежду собой) вы можете указать 
//   значение MATRIX_TYPE == 2 - использовать для адресации светодиодов на ленте (перевод из координат x,y в индекс светодиода) специальный массив индексов, 
//   загружаемый из файла или определенный в скетче как массив PROGMEM. 
//
//   Настройки параметров матрицы для этого типа подключения (MATRIX_TYPE == 2):
//
//   WIDTH                   - полная ширина сборной матрицы, включая все сегменты
//   HEIGHT                  - полная высота  сборной матрицы, включая все сегменты
//   MATRIX_TYPE             - значение должно быть 2 - используется карта индексов
//   CONNECTION_ANGLE        - не используется
//   STRIP_DIRECTION         - не используется
//   MATRIX_INDEX            - место расположения массива индексов 
//                             0 - в сектче в файле index_map.ino 
//                             1 - в файле карты индексов в файловой системе микроконтроллера 
//   META_MATRIX_WIDTH       - значение должно быть обязательно 1
//   META_MATRIX_HEIGHT      - значение должно быть обязательно 1
//   META_MATRIX_TYPE        - не используется
//   META_MATRIX_ANGLE       - не используется
//   META_MATRIX_DIRECTION   - не используется
//
//   Для создания индексного файла (карта индексов) используется утилита LedMapper, которая находится в папке tools проекта.
//   Имя файла индексов имеет формат "WxH.map" где W - ширина матрицы, H - высота матрицы (для матрицы 35x20 имя файла "35x20.map")
//
//   Для загрузки файла в файловую систему микроконтроллера поместите файл в папку data, находящуюся в папке скетча.
//   В меню "Инструменты" Arduino IDE в настройке распределения памяти устройства выберите вариант:
//     Для микроконтроллеров ESP8266 с 4МБ флэш-памяти рекомендуется вариант "Flash Size: 4MB(FS:2MB OTA:~1019KB)"
//     Для микроконтроллеров ESP32   с 4МБ флэш-памяти рекомендуется вариант "Partition scheme: Default 4MB with spiff(1.2MB APP/1.5MB SPIFFS)"; 
//
//   Загрузка выполняется утилитой "ESP8266 LittleFS Data Upload: для контроллеров на базе ESP8266
//   или утилитой "ESP32 LittleFS Data Upload: для контроллеров на базе ESP32
//   Эти утилиты находятся в папке проекта "tools/LittleFS_Uploader" - нужно установить их в IDE согласно инструкции в файлк readme
//
//   Если при старте микроконтроллер не нейдет файл в файловой системе - для адресации диодов на матрице будут использованы  
//   параметры типа матрицы MATRIX_TYPE == 0 - зигзаг
//
//   При указании параметра MATRIX_INDEX == 0 - PROGMEM массив карты индексов imap размещен в скетче в файле index_map.ino
//   Замените содержимое массива imap> приведенное для примера на массив, сформированный для вашей матрице в утилите LedMapper 
// 

// =================== ESP8266 (NodeMCU, Wemos d1) ===================

/*
 * Wemos d1 mini (clone), NodeMCU v1.0 (ESP-12E)
 */ 
 
#if defined(ESP8266)

#if (DEVICE_VARIANT == 0)

// ===========================================================================
// ВНИМАНИЕ !!!
//
// ВСЕ НАСТРОЙКИ, ВКЛЮЧАЯ НАЗНАЧЕНИЕ ПИНОВ, ПРИМЕНЯЮТСЯ ПРИ ПЕРВОЙ ЗАГРУЗКЕ ПРОШИВКИ В ЧИСТЫЙ МИКРОКОНТРОЛЛЕР, ЗАТЕМ СОХРАНЯЮТСЯ В EEPROM
// И ПРИ СЛЕДУЮЩИХ ЗАПУСКАХ ИСПОЛЬЗУЮТСЯ ЗНАЧЕНИЯ, СОХРАНЕННЫЕ В ПАМЯТИ, А НЕ ПРОПИСАННЫЕ В СКЕТЧЕ.
//
// ЕСЛИ ВЫ ИЗМЕНИЛИ НАСТРОЙКИ ЗДЕСЬ, ДЛЯ ТОГО, ЧТОБЫ ОНИ БЫЛИ ПРИМЕНЕНЫ В ПРОШИВКЕ, ВЫПОЛНИТЕ ОДНО ИЗ СЛЕДУЮЩИХ ДЕЙСТВИЙ:
//   А) ПОСЛЕ ПРОШИВКИ ЗАЙДИТЕ В WEB-ПРИЛОЖЕНИЕ НА СТРАНИЧКУ НАСТРОЙКИ И ИЗМЕНИТЕ ПАРАМЕТРЫ И НАЗНАЧЕНИЕ ПИНОВ ТАМ
//   Б) ПЕРЕД ЗАГРУЗКОЙ ПРОШИВКИ В МИКРОКОНТРОЛЛЕР ИЗМЕНИТЕ ЗНАЧЕНИЕ КОНСТАНТЫ EEPROM_OK В ФАЙЛЕ a_def_soft.h НА любое ДРУГОЕ шестнадцатеричное значение (один байт)
//   В) ЗАГРУЖАЙТЕ ПРОШИВКУ В МИКРОКОНТРОЛЛЕР С ОПЦИЕЙ В МЕНЮ "ИНСТРУМЕНТЫ" - "Erase Flash" - "All Flash Contents" для ESP8266 или
//      "Erase all flash before sketch upload" - "Enabled" для ESP32
//
// ===========================================================================
 
// Для адресации строки/столбца матрицы используется тип int8_t (-128..127), т.к. нужны отрицательные значения для прокрутки часов и текста бегущей строки, 
// поэтому ширина/высота матрицы не может быть больше 128

#define WIDTH 16                /* ширина одного сегмента матрицы для MATRIX_TYPE == 0 или MATRIX_TYPE == 1                                       | для MATRIX_TYPE == 2 ПОЛНАЯ ШИРИНА матрицы   */
#define HEIGHT 16               /* высота одного сегмента матрицы для MATRIX_TYPE == 0 или MATRIX_TYPE == 1                                       | для MATRIX_TYPE == 2 ПОЛНАЯ ВЫСОТА матрицы   */ 
#define MATRIX_TYPE 0           /* тип соединения диодов в сегменте матрицы: 0 - зигзаг, 1 - параллельная, 2 - использовать карту индексов                                                       */
#define MATRIX_INDEX 1          /* только для MATRIX_TYPE == 2 - место расположения массива индексов 0 - в сектче, 1 - в файле                    | для MATRIX_TYPE == 0 или 1 - поставьте тут 1 */
#define CONNECTION_ANGLE 1      /* угол подключения диодов в сегменте: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний | для MATRIX_TYPE == 2 - не используется       */
#define STRIP_DIRECTION 3       /* направление ленты из угла сегмента: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз                                 | для MATRIX_TYPE == 2 - не используется       */

#define META_MATRIX_WIDTH 1     /* количество сегментов в ширину сборной матрицы                                                                  | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_HEIGHT 1    /* количество сегментов в высоту сборной матрицы                                                                  | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_TYPE 0      /* тип сборной матрицы: 0 - зигзаг, 1 - параллельная                                                              | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_ANGLE 0     /* угол 1-го сегмента сборной матрицы: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний | для MATRIX_TYPE == 2 - не используется       */ 
#define META_MATRIX_DIRECTION 0 /* направление следующих сегментов сборной матрицы из угла: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз            | для MATRIX_TYPE == 2 - не используется       */

#define COLOR_ORDER       GRB   /* Порядок цветов на ленте - RGB,RBG,GRB,GBR,BRG,BGR; Если цвет отображается некорректно - меняйте. Начать можно с RGB */
#define LED_CHIP      WS2812B   /* CHIP ленты для библиотеки FASTLED - это 3-х проводные чипы с программным SPI.   // Для чипов с аппаратным CLK потребуется изменить функцию allocateLeds() в utility.ino; */
                                //   WS2811, WS2812, WS2812B, WS2813, WS2852, APA104, APA106, SK6812, SK6822,      // Поддерживается до 4-х сегментов вывода на свои аппаратные пины, вывод на которые
                                //   TM1803, TM1804, TM1809, TM1812, TM1829, UCS1903, UCS1903B, UCS1904, UCS2903,  // назначены одинаковым LED_CHIP и COLOR_ORDER, Если ленты или порядок цвета в сегментах разные - требуется изменить функцию allocateLeds() в utility.ino;
                                //   PL9823, GE8822, GS1903, GW6205, LPD1886, SM16703

#define DEVICE_TYPE 1           /* Использование матрицы: 0 - свернута в трубу для лампы; 1 - плоская матрица в рамке                                  */
#define BUTTON_TYPE 1           /* Тип кнопки: 0 - сенсорная (touch button); 1 - обычная кнопка на замыкание при нажатии (или если кнопки нет вообще)  */
#define USE_BUTTON 1            /* 1 - использовать кнопку управления; 0 - не использовать                                                             */
#define USE_OTA 1               /* 1 - использовать обновление "по воздуху", 0 - не использовать                                                       */
#define USE_ANIMATION 1         /* 1 - использовать эффекты "Анимация" и "Погода", 0 - не использовать                                                 */

// --- !!! Внимание - TM1637 не совместим с SD-картой,т.к. используют одни и те же линии При включенном USE_TM1637==1 SD-карта работать не будет !!! ---
// --- !!! Для совместной работы TM1637 и SD-карты исаользуйте кнофигурацию DEVICE_VARIANT == 1 -- там линии разнесены

// -------- Пины дополнительного управления - следите, чтобы при включенных USE_POWER, USE_ALARM, USE_AUX пины управления не пересекались, иначе при совпадении пинов одна фича будет включать пин, другая в то же время - выключать 

#define USE_POWER 1             /* 1 - использовать отключение питания матрицы через MOSFET / реле; 0 - не использовать          */
#define POWER_ON  HIGH          /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин POWER_PIN высокий уровень  */
#define POWER_OFF LOW           /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин POWER_PIN низкий уровень   */

#define USE_ALARM 0             /* 1 - использовать включение сигнала на ALARM_PIN во время срабатывания будильника              */
#define ALARM_ON  HIGH          /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин ALARM_PIN высокий уровень  */
#define ALARM_OFF LOW           /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин ALARM_PIN низкий уровень   */

#define USE_AUX 0               /* 1 - использовать включение сигнала на AUX_PIN во время срабатывания будильника                */
#define AUX_ON  HIGH            /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин AUX_PIN высокий уровень    */
#define AUX_OFF LOW             /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин AUX_PIN низкий уровень     */

// -------- 

#define USE_TM1637 0            /* поставьте 1, если используется дополнительный индикатор TM1637, 0 если индикатора нет */
#define USE_WEATHER 1           /* 1 - использовать получение информации о текущей погоде; 0 - не использовать */

#define USE_E131 0              /* 1 - использовать протокол E1.31 для синхронизации устройств или приема внешнего потока на матрицу с Jinx! или другого аналогичного ПО */
#define E131_FRAME_DELAY 20     /* Минимальное время между отправкой экранов слушателем в миллисекундах */
                                /* Экран матрицы может формироваться чаще чем указанный промежуток. Если со времени предыдущей отправки кадра прошло менее E131_FRAME_DELAY миллисекунд */
                                /* кадр не отправлять. Тогда возможно подергивание на приемниках. */
                                /* Чтобы подергивания не было - нужно уменьшать это значение. Однако слишком частая отправка экранов клиентам */
                                /* может забивать сеть до полного зависания роутера и отваливания сети на всех компьютерах - зависит от производительности роутера */

#define BIG_FONT 0              /* 0 - шрифт 5x8, 1 - шрифт  10x16; 2 - шрифт 8x13 */

// --- !!! Внимание - SD-карта несовместима с TM1637 ,т.к. используют одни и те же линии. При включенном USE_TM1637==1 SD-карта работать не будет !!! ---
// --- !!! Для совместной работы TM1637 и SD-карты исаользуйте кнофигурацию DEVICE_VARIANT == 1 -- там линии разнесены

#define USE_SD 0                /* поставьте 0, если у вас нет SD-card модуля */
#define FS_AS_SD 0              /* при USE_SD == 1; FS_AS_SD == 0 - эффекты на SD-карте, 1 - эффекты в файловой ситеме МК, самого SD-card модуля нет (режим эмуляции SD-карты для эффектов 'SD-карта') */
                                // Для USE_SD == 1 - поведение при проигрывании файла эффекта с SD-карты 
#define WAIT_PLAY_FINISHED 1    /* 1 - переключаться на следующий эффект только когда весь файл полностью показан; */
                                // 0 - прерывать показ файла с SD-карты по истечении времени эффекта
#define REPEAT_PLAY 0           /* 1 - повторное проигрывание текущего эффекта, если время не вышло; 0 - следующий эффект */
// -------

// DFPlayer выпускается разными производителями на разных чипах. 
// Оригинальный плеер построен на микросхеме с обозначением на корпусе AS20HH5883-74
// Существует множество клонов DFPlayer от других производителей, построенных на других чипах, например MH2024K-24SS, MH2024K-16SS и др.
// Эти чипы отличаются от оригинальных несколько измененной системой команд. Библиотеке нужно знать команды в каком формате отправлять плееру.
// Укажите ниже какой чип использован в в вашем DFPlayer
// -------
#define USE_MP3 0               /* поставьте 0, если у вас нет звуковой карты MP3 плеера */
#define DFPLAYER_TYPE 0         /* 0 - AS20HH5883-74 (оригинальный); 1 - MH2024K-24SS, MH2024K-16SS (клон) */
#define GUARD_DELAY 0           /* Задержка между отправкой последовательных команд в модуль DFPlayer 0..15 мс */
                                // Рекомендуется подбирать опытным путем. Слишком большая задержка может давать суммарно до 0.5 сек замирания эффектов при начале/окончании воспроизведения звука.
                                // Слишком маленькая задержка может приводить к необнаружению плеера прошивкой или даже циклическую перезагрузку контроллера
                                // Если плеер обнаруживается прошивкой, но не удается получить список файлов с SD-карты и в приложении отсутствует выбор звуков
                                // будильника - увеличивайте значение задержки
                                //
                                // Чудеса в решете:
                                //
                                // В некоторых сборках при попытках сохранить настройки будильника или проиграть выбранный в программе в настройках звука файл                                 
                                // Вызывает крах системы с перезагрузкой микроконтроллера. Крах происходит в файле библиотеки плеера DFMiniMp3.h в строке примерно 533 (в версии библиотеки 1.1.1)
                                // в функции sendPacket()
                                // в этой строке --> _serial.write(reinterpret_cast<uint8_t*>(&packet), sizeof(packet));
                                //
                                // Ошибку удалось победить добавив в начало файла DFMiniMp3.h строку 28 следующий дефайн:
                                // #define DfMiniMp3Debug Serial
                                // После компиляции сборки с этой строкой вызов функций плеера начинает "гадить" в монитор потта, но преер крашиться перестает
                                // Впрочем, если просто закомментировать эту строку и снова пересобрать программу, плеер все равно продолжает работать без "падений".
                                // Необъяснимо, но факт.
// -------

#if (USE_SD == 1 && USE_TM1637 == 1)
  // Одновременное использование SD-карты и индикатора TM1637 не поддерживается - они оба используют пины D5 и D7 - конфликт
  #error Unable to use SD-card and TM1637 display due the usage of the same conflicting pins D5 and D7 by the both devices
#endif

#define LED_PIN D2              // D2 пин ленты
#define PIN_BTN D1              // физическая кнопка подключена сюда (D1--- КНОПКА --- GND);

#define STX D3                  // подключен в RX пин (2) модуля DFPlayer
#define SRX D4                  // подключен в TX пин (3) модуля DFPlayer
#define DIO D5                  // D5 TM1637 display DIO pin - требуется для компиляции скетча (USE_TM1637 == 1) - D5 только если не подключена SD-карта, которая использунт эти пины
#define CLK D7                  // D7 TM1637 display CLK pin - требуется для компиляции скетча (USE_TM1637 == 1) - D7 только если не подключена SD-карта, которая использунт эти пины

// SD-карта подключается к аппаратным пинам SPI, которые различны для разных тип плат ESP32 - WROOM-32, S2, S3, C2, C3, C6 и определены в ядре как SS, MOSI, MISO, SCK

#define SD_CS_PIN D8            // пин выбора SD карты - D8 (CS); Также SD карта использует D5 (CLK), D6 (MISO), D7 (MOSI) (пины определены в ядре микрооконтроллера)

// Сдедите, чтобы пины дополнительного управления при включенной фиче не пересекались, иначе одна фича будет устанавливать сигнал на пине, другая снимать и ничего работать не будет
// Настраивайте эти пины из WEBUI, там есть контроль назначения пинов, исключающий их пересечение

#define POWER_PIN D0            // D0 управляющий пин вкл/выкл матрицы через MOSFET / реле; POWER_ON - HIGH, POWER_OFF - LOW
#define ALARM_PIN D0            // D0 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
#define AUX_PIN D1              // D0 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW

#define DEBUG_SERIAL 1          // включить/выключить отладочный вывод в Serial: 0 - выключено 1 - включено
#endif

#if (DEVICE_VARIANT == 1)

// ===========================================================================
// ВНИМАНИЕ !!!
//
// ВСЕ НАСТРОЙКИ, ВКЛЮЧАЯ НАЗНАЧЕНИЕ ПИНОВ, ПРИМЕНЯЮТСЯ ПРИ ПЕРВОЙ ЗАГРУЗКЕ ПРОШИВКИ В ЧИСТЫЙ МИКРОКОНТРОЛЛЕР, ЗАТЕМ СОХРАНЯЮТСЯ В EEPROM
// И ПРИ СЛЕДУЮЩИХ ЗАПУСКАХ ИСПОЛЬЗУЮТСЯ ЗНАЧЕНИЯ, СОХРАНЕННЫЕ В ПАМЯТИ, А НЕ ПРОПИСАННЫЕ В СКЕТЧЕ.
//
// ЕСЛИ ВЫ ИЗМЕНИЛИ НАСТРОЙКИ ЗДЕСЬ, ДЛЯ ТОГО, ЧТОБЫ ОНИ БЫЛИ ПРИМЕНЕНЫ В ПРОШИВКЕ, ВЫПОЛНИТЕ ОДНО ИЗ СЛЕДУЮЩИХ ДЕЙСТВИЙ:
//   А) ПОСЛЕ ПРОШИВКИ ЗАЙДИТЕ В web-ПРИЛОЖЕНИЕ НА СТРАНИЧКУ НАСТРОЙКИ И ИЗМЕНИТЕ ПАРАМЕТРЫ И НАЗНАЧЕНИЕ ПИНОВ ТАМ
//   Б) ПЕРЕД ЗАГРУЗКОЙ ПРОШИВКИ В МИКРОКОНТРОЛЛЕР ИЗМЕНИТЕ ЗНАЧЕНИЕ КОНСТАНТЫ EEPROM_OK В ФАЙЛЕ a_def_soft.h НА ДРУГОЕ
//   В) ЗАГРУЖАЙТЕ ПРОШИВКУ В МИКРОКОНТРОЛЛЕР С ОПЦИЕЙ В МЕНЮ "ИНСТРУМЕНТЫ" - "Erase Flash" - "All Flash Contents" для ESP8266 или
//      "Erase all flash before sketch upload" - "Enabled" для esp32
//
// ===========================================================================

// Для адресации строки/столбца матрицы используется тип int8_t (-128..127), т.к. нужны отрицательные значения для прокрутки часов и текста бегущей строки, 
// поэтому ширина/высота матрицы не может быть больше 128

// Схему соединений смотри в папке "schemes" проекта
// ESP8266+ALL.JPG             - подключены все возможные компоненты, сенсорная кнопка (BUTTON_TYPE == 0)
#define WIDTH 16                /* ширина одного сегмента матрицы для MATRIX_TYPE == 0 или MATRIX_TYPE == 1                                       | для MATRIX_TYPE == 2 ПОЛНАЯ ШИРИНА матрицы   */
#define HEIGHT 16               /* высота одного сегмента матрицы для MATRIX_TYPE == 0 или MATRIX_TYPE == 1                                       | для MATRIX_TYPE == 2 ПОЛНАЯ ВЫСОТА матрицы   */
#define MATRIX_TYPE 0           /* тип соединения диодов в сегменте матрицы: 0 - зигзаг, 1 - параллельная, 2 - использовать карту индексов                                                       */
#define MATRIX_INDEX 1          /* только для MATRIX_TYPE == 2 место расположения массива индексов 0 - в сектче, 1 - в файле                      | для MATRIX_TYPE == 0 или 1 - поставьте тут 1 */
#define CONNECTION_ANGLE 0      /* угол подключения диодов в сегменте: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний | для MATRIX_TYPE == 2 - не используется       */
#define STRIP_DIRECTION 0       /* направление ленты из угла сегмента: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз                                 | для MATRIX_TYPE == 2 - не используется       */

#define META_MATRIX_WIDTH 1     /* количество сегментов в ширину сборной матрицы                                                                  | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_HEIGHT 1    /* количество сегментов в высоту сборной матрицы                                                                  | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_TYPE 0      /* тип сборной матрицы: 0 - зигзаг, 1 - параллельная                                                              | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_ANGLE 0     /* угол 1-го сегмента сборной матрицы: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_DIRECTION 0 /* направление следующих сегментов сборной матрицы из угла: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз            | для MATRIX_TYPE == 2 - не используется       */

#define COLOR_ORDER        GRB  /* Порядок цветов на ленте - RGB,RBG,GRB,GBR,BRG,BGR; Если цвет отображается некорректно - меняйте. Начать можно с RGB */
#define LED_CHIP       WS2812B  /* CHIP ленты для библиотеки FASTLED - это 3-х проводные чипы с программныь SPI.   // Для чипов с аппаратным CLK потребуется изменить функцию allocateLeds() в utility.ino; */
                                //   WS2811, WS2812, WS2812B, WS2813, WS2852, APA104, APA106, SK6812, SK6822,      // Поддерживается до 4-х сегментов вывода на свои аппаратные пины, вывод на которые
                                //   TM1803, TM1804, TM1809, TM1812, TM1829, UCS1903, UCS1903B, UCS1904, UCS2903,  // назначены одинаковым LED_CHIP и COLOR_ORDER, Если ленты или порядок цвета в сегментах разные - требуется изменить функцию allocateLeds() в utility.ino;
                                //   PL9823, GE8822, GS1903, GW6205, LPD1886, SM16703

#define DEVICE_TYPE 1           /* Использование матрицы: 0 - свернута в трубу для лампы; 1 - плоская матрица в рамке */
#define BUTTON_TYPE 1           /* Тип кнопки: 0 - сенсорная (touch button); 1 - обычная кнопка на замыкание при нажатии (или если кнопки нет вообще) */
#define USE_BUTTON 1            /* 1 - использовать кнопку управления; 0 - не использовать                                                            */
#define USE_OTA 1               /* 1 - использовать обновление "по воздуху", 0 - не использовать                                                      */
#define USE_ANIMATION 0         /* 1 - использовать эффекты "Анимация" и "Погода", 0 - не использовать                                                */

// -------- Пины дополнительного управления - следите, чтобы при включенных USE_POWER, USE_ALARM, USE_AUX пины управления не пересекались, иначе при совпадении пинов одна фича будет включать пин, другая в то же время - выключать 

#define USE_POWER 1             /* 1 - использовать отключение питания матрицы через MOSFET / реле; 0 - не использовать          */
#define POWER_ON  HIGH          /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин POWER_PIN высокий уровень  */
#define POWER_OFF LOW           /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин POWER_PIN низкий уровень   */

#define USE_ALARM 0             /* 1 - использовать включение сигнала на ALARM_PIN во время срабатывания будильника              */
#define ALARM_ON  HIGH          /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин ALARM_PIN высокий уровень  */
#define ALARM_OFF LOW           /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин ALARM_PIN низкий уровень   */

#define USE_AUX 0               /* 1 - использовать включение сигнала на AUX_PIN во время срабатывания будильника                */
#define AUX_ON  HIGH            /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин AUX_PIN высокий уровень    */
#define AUX_OFF LOW             /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин AUX_PIN низкий уровень     */

// -------- 

#define USE_TM1637 1            /* поставьте 1, если используется дополнительный индикатор TM1637, 0 если индикатора нет */
#define USE_WEATHER 1           /* 1 - использовать получение информации о текущей погоде; 0 - не использовать */
#define USE_E131 0              /* 1 - использовать протокол E1.31 для синхронизации устройств или приема внешнего потока на матрицу с Jinx! или другого аналогичного ПО */
#define E131_FRAME_DELAY 25     /* Минимальное время между отправкой экранов слушателем в миллисекундах */
                                /* Экран матрицы может формироваться чаще чем указанный промежуток. Если со времени предыдузщй отправки кадра прошло менее E131_FRAME_DELAY миллисекунд */
                                /* кадр не отправлять. Тогда возможно подергивание на приемниках. */
                                /* Чтобы подергивания не было - нужно уменьшать это значение. Однако слишком частая отправка экранов клиентам */
                                /* может забивать сеть до полного зависания роутера и отваливания сети на всех компьютерах - зависит от производительности роутера */

#define BIG_FONT 0              /* 0 - шрифт 5x8, 1 - шрифт  10x16; 2 - шрифт 8x13 */

// -------
#define USE_SD 1                /* поставьте 0, если у вас нет SD-card модуля */
#define FS_AS_SD 0              /* при USE_SD == 1; FS_AS_SD == 0 - эффекты на SD-карте, 1 - эффекты в файловой ситеме МК, самого SD-card модуля нет (режим эмуляции SD-карты для эффектов 'SD-карта') */
                                // Для USE_SD == 1 - поведение при проигрывании файла эффекта с SD-карты 
#define WAIT_PLAY_FINISHED 1    /* 1 - переключаться на следующий эффект только когда весь файл полностью показан; */
                                // 0 - прерывать показ файла с SD-карты по истечении времени эффекта
#define REPEAT_PLAY 0           /* 1 - повторное проигрывание текущего эффекта, если время не вышло; 0 - следующий эффект */
// -------

// DFPlayer выпускается разными производителями на разных чипах. 
// Оригинальный плеер построен на микросхеме с обозначением на корпусе AS20HH5883-74
// Существует множество клонов DFPlayer от других производителей, построенных на других чипах, например MH2024K-24SS, MH2024K-16SS и др.
// Эти чипы отличаются от оригинальных несколько измененной системой команд. Библиотеке нужно знать команды в каком формате отправлять плееру.
// Укажите ниже какой чип использован в в вашем DFPlayer

// -------
#define USE_MP3 1               /* поставьте 0, если у вас нет звуковой карты MP3 плеера */
#define DFPLAYER_TYPE 0         /* 0 - AS20HH5883-74 (оригинальный); 1 - MH2024K-24SS, MH2024K-16SS (клон) */
#define GUARD_DELAY 0           /* Задержка между отправкой последовательных команд в модуль DFPlayer 0..15 мс */
                                // Рекомендуется подбирать опытным путем. Слишком большая задержка может давать суммарно до 0.5 сек замирания эффектов при начале/окончании воспроизведения звука.
                                // Слишком маленькая задержка может приводить к необнаружению плеера прошивкой или даже циклическую перезагрузку контроллера
                                // Если плеер обнаруживается прошивкой, но не удается получить список файлов с SD-карты и в приложении отсутствует выбор звуков
                                // будильника - увеличивайте значение задержки
// -------
                                
// Внимание!!!
// Если используется сенсорная кнопка - для прошивки ESP8266 необходимо отсоединить управляющий провод идущий от кнопки до Rx.
// Исследования по совместимости пинов и оборудования для ESP8266 можно посмотреть по адресу: "https://github.com/vvip-68/LedPanelWiFi/wiki/Продвинутый-уровень.-Использование-портов-микроконтроллера."

#define LED_PIN D2              /* D2 физческий пин ленты */
#define PIN_BTN D9              /* кнопка подключена сюда (D9 --- КНОПКА --- GND) */

#define STX D3                  /* подключен в RX пин (2) модуля DFPlayer */
#define SRX D4                  /* подключен в TX пин (3) модуля DFPlayer */

#define DIO D0                  /* TM1637 display DIO pin */
#define CLK D10                 /* TM1637 display CLK pin */

#define SD_CS_PIN D8            // !!! не менять !!! - пин выбора SD карты - D8 (CS); Также SD карта использует D5 (CLK), D6 (MISO), D7 (MOSI) (пины определены в ядре микрооконтроллера - аппаратный SPI)

// Следите, чтобы пины дополнительного управления при включенной фиче не пересекались, иначе одна фича будет устанавливать сигнал на пине, другая снимать и ничего работать не будет
// Настраивайте эти пины из WEBUI? там есть контроль назначения пинов, исключающий их пересечение

#define POWER_PIN D1            /* D1 управляющий пин вкл/выкл матрицы через MOSFET / реле; POWER_ON - HIGH, POWER_OFF - LOW */
#define ALARM_PIN D1            /* D1 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW */
#define AUX_PIN D1              /* D1 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW */

// Внимание!!!
// Данная компоновка работает только при отключенном отладочном выводе (DEBUG_SERIAL == 0), поскольку вывод в Serial использует D9 и D10 
// которые в данной схеме заняты под пин кнопки и пин CLK TM1637

#define DEBUG_SERIAL 0          /* включить/выключить отладочный вывод в Serial: 0 - выключено 1 - включено */

#endif

#endif

// ============================== ESP32 ==============================

/*
 * ESP32
 * В менеджере плат выбрано "ESP32 Dev Module"
 */ 

// Схемы соединений смотри в папке "schemes" проекта
// ESP32+ALL.JPG             - подключены все возможные компоненты, сенсорная кнопка (BUTTON_TYPE == 0)
// ESP32+button_noRELAY.jpg  - нет реле для управления питанием матрицы, обычная кнопка (BUTTON_TYPE == 1)
// ESP32+MOSFET.JPG          - управления питанием матрицы через MOSFET, сенсорная кнопка  (BUTTON_TYPE == 0)

// ===========================================================================
// ВНИМАНИЕ !!!
//
// ВСЕ НАСТРОЙКИ, ВКЛЮЧАЯ НАЗНАЧЕНИЕ ПИНОВ, ПРИМЕНЯЮТСЯ ПРИ ПЕРВОЙ ЗАГРУЗКЕ ПРОШИВКИ В ЧИСТЫЙ МИКРОКОНТРОЛЛЕР, ЗАТЕМ СОХРАНЯЮТСЯ В EEPROM
// И ПРИ СЛЕДУЮЩИХ ЗАПУСКАХ ИСПОЛЬЗУЮТСЯ ЗНАЧЕНИЯ, СОХРАНЕННЫЕ В ПАМЯТИ, А НЕ ПРОПИСАННЫЕ В СКЕТЧЕ.
//
// ЕСЛИ ВЫ ИЗМЕНИЛИ НАСТРОЙКИ ЗДЕСЬ, ДЛЯ ТОГО, ЧТОБЫ ОНИ БЫЛИ ПРИМЕНЕНЫ В ПРОШИВКЕ, ВЫПОЛНИТЕ ОДНО ИЗ СЛЕДУЮЩИХ ДЕЙСТВИЙ:
//   А) ПОСЛЕ ПРОШИВКИ ЗАЙДИТЕ В web-ПРИЛОЖЕНИЕ НА СТРАНИЧКУ НАСТРОЙКИ И ИЗМЕНИТЕ ПАРАМЕТРЫ И НАЗНАЧЕНИЕ ПИНОВ ТАМ
//   Б) ПЕРЕД ЗАГРУЗКОЙ ПРОШИВКИ В МИКРОКОНТРОЛЛЕР ИЗМЕНИТЕ ЗНАЧЕНИЕ КОНСТАНТЫ EEPROM_OK В ФАЙЛЕ a_def_soft.h НА ДРУГОЕ
//   В) ЗАГРУЖАЙТЕ ПРОШИВКУ В МИКРОКОНТРОЛЛЕР С ОПЦИЕЙ В МЕНЮ "ИНСТРУМЕНТЫ" - "Erase Flash" - "All Flash Contents" для ESP8266 или
//      "Erase all flash before sketch upload" - "Enabled" для esp32
//
// ===========================================================================

// Для адресации строки/столбца матрицы используется тип int8_t (-128..127), т.к. нужны отрицательные значения для прокрутки часов и текста бегущей строки, 
// поэтому ширина/высота матрицы не может быть больше 128

#if defined(ESP32)

#define WIDTH 16                /* ширина одного сегмента матрицы для MATRIX_TYPE == 0 или MATRIX_TYPE == 1                                       | для MATRIX_TYPE == 2 ПОЛНАЯ ШИРИНА матрицы   */
#define HEIGHT 16               /* высота одного сегмента матрицы для MATRIX_TYPE == 0 или MATRIX_TYPE == 1                                       | для MATRIX_TYPE == 2 ПОЛНАЯ ВЫСОТА матрицы   */
#define MATRIX_TYPE 0           /* тип соединения диодов в сегменте матрицы: 0 - зигзаг, 1 - параллельная, 2 - использовать карту индексов                                                       */
#define MATRIX_INDEX 1          /* только для MATRIX_TYPE == 2 место расположения массива индексов 0 - в сектче, 1 - в файле                      | для MATRIX_TYPE == 0 или 1 - поставьте тут 1 */
#define CONNECTION_ANGLE 1      /* угол подключения диодов в сегменте: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний | для MATRIX_TYPE == 2 - не используется       */
#define STRIP_DIRECTION 3       /* направление ленты из угла сегмента: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз                                 | для MATRIX_TYPE == 2 - не используется       */

#define META_MATRIX_WIDTH 1     /* количество сегментов в ширину сборной матрицы                                                                  | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_HEIGHT 1    /* количество сегментов в высоту сборной матрицы                                                                  | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_TYPE 0      /* тип сборной матрицы: 0 - зигзаг, 1 - параллельная                                                              | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_ANGLE 0     /* угол 1-го сегмента сборной матрицы: 0 - левый нижний, 1 - левый верхний, 2 - правый верхний, 3 - правый нижний | для MATRIX_TYPE == 2 - не используется       */
#define META_MATRIX_DIRECTION 0 /* направление следующих сегментов сборной матрицы из угла: 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз            | для MATRIX_TYPE == 2 - не используется       */

#define COLOR_ORDER        GRB  /* Порядок цветов на ленте - RGB,RBG,GRB,GBR,BRG,BGR; Если цвет отображается некорректно - меняйте. Начать можно с RGB */
#define LED_CHIP       WS2812B  /* CHIP ленты для библиотеки FASTLED - это 3-х проводные чипы с программныь SPI.   // Для чипов с аппаратным CLK потребуется изменить функцию allocateLeds() в utility.ino; */
                                //   WS2811, WS2812, WS2812B, WS2813, WS2852, APA104, APA106, SK6812, SK6822,      // Поддерживается до 4-х сегментов вывода на свои аппаратные пины, вывод на которые
                                //   TM1803, TM1804, TM1809, TM1812, TM1829, UCS1903, UCS1903B, UCS1904, UCS2903,  // назначены одинаковым LED_CHIP и COLOR_ORDER, Если ленты или порядок цвета в сегментах разные - требуется изменить функцию allocateLeds() в utility.ino;
                                //   PL9823, GE8822, GS1903, GW6205, LPD1886, SM16703

#define DEVICE_TYPE 1           /* Использование матрицы: 0 - свернута в трубу для лампы; 1 - плоская матрица в рамке */
#define BUTTON_TYPE 1           /* Тип кнопки: 0 - сенсорная (touch button); 1 - обычная кнопка на замыкание при нажатии (или если кнопки нет вообще) */
#define USE_BUTTON 1            /* 1 - использовать кнопку управления; 0 - не использовать                                                            */
#define USE_OTA 1               /* 1 - использовать обновление "по воздуху", 0 - не использовать                                                      */
#define USE_ANIMATION 0         /* 1 - использовать эффекты "Анимация" и "Погода", 0 - не использовать                                                */

// -------- Пины дополнительного управления - следите, чтобы при включенных USE_POWER, USE_ALARM, USE_AUX пины управления не пересекались, иначе при совпадении пинов одна фича будет включать пин, другая в то же время - выключать 

#define USE_POWER 1             /* 1 - использовать отключение питания матрицы через MOSFET / реле; 0 - не использовать          */
#define POWER_ON  HIGH          /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин POWER_PIN высокий уровень  */
#define POWER_OFF LOW           /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин POWER_PIN низкий уровень   */

#define USE_ALARM 1             /* 1 - использовать включение сигнала на ALARM_PIN во время срабатывания будильника              */
#define ALARM_ON  HIGH          /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин ALARM_PIN высокий уровень  */
#define ALARM_OFF LOW           /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин ALARM_PIN низкий уровень   */

#define USE_AUX 1               /* 1 - использовать включение сигнала на AUX_PIN во время срабатывания будильника                */
#define AUX_ON  HIGH            /* Для включения  питания матрицы (через MOSFET/реле) подавать на пин AUX_PIN высокий уровень    */
#define AUX_OFF LOW             /* Для вЫключения питания матрицы (через MOSFET/реле) подавать на пин AUX_PIN низкий уровень     */

// -------

#define USE_TM1637 1            /* поставьте 1, если используется дополнительный индикатор TM1637, 0 если индикатора нет */
#define USE_WEATHER 1           /* 1 - использовать получение информации о текущей погоде; 0 - не использовать */
#define USE_E131 1              /* 1 - использовать протокол E1.31 для синхронизации устройств или приема внешнего потока на матрицу с Jinx! или другого аналогичного ПО */
#define E131_FRAME_DELAY 25     /* Минимальное время между отправкой экранов слушателем в миллисекундах */
                                /* Экран матрицы может формироваться чаще чем указанный промежуток. Если со времени предыдузщй отправки кадра прошло менее E131_FRAME_DELAY миллисекунд */
                                /* кадр не отправлять. Тогда возможно подергивание на приемниках. */
                                /* Чтобы подергивания не было - нужно уменьшать это значение. Однако слишком частая отправка экранов клиентам */
                                /* может забивать сеть до полного зависания роутера и отваливания сети на всех компьютерах - зависит от производительности роутера */
#define BIG_FONT 0              /* 0 - шрифт 5x8, 1 - шрифт  10x16; 2 - шрифт 8x13 */

// -------

#define USE_SD 1                /* поставьте 0, если у вас нет SD-card модуля */
#define FS_AS_SD 0              /* при USE_SD == 1; FS_AS_SD == 0 - эффекты на SD-карте, 1 - эффекты в файловой ситеме МК, самого SD-card модуля нет (режим эмуляции SD-карты для эффектов 'SD-карта') */
                                // Для USE_SD == 1 - поведение при проигрывании файла эффекта с SD-карты 
#define WAIT_PLAY_FINISHED 1    /* 1 - переключаться на следующий эффект только когда весь файл полностью показан; */
                                // 0 - прерывать показ файла с SD-карты по истечении времени эффекта
#define REPEAT_PLAY 0           /* 1 - повторное проигрывание текущего эффекта, если время не вышло; 0 - следующий эффект */

// -------

// DFPlayer выпускается разными производителями на разных чипах. 
// Оригинальный плеер построен на микросхеме с обозначением на корпусе AS20HH5883-74
// Существует множество клонов DFPlayer от других производителей, построенных на других чипах, например MH2024K-24SS, MH2024K-16SS, GB3200B и др.
// Эти чипы отличаются от оригинальных несколько измененной системой команд. Библиотеке нужно знать команды в каком формате отправлять плееру.
// Укажите ниже какой чип использован в в вашем DFPlayer

#define USE_MP3 1               /* поставьте 0, если у вас нет звуковой карты MP3 плеера */
#define DFPLAYER_TYPE 0         /* 0 - AS20HH5883-74 (оригинальный); 1 - MH2024K-24SS, MH2024K-16SS, GB3200B (клон) */
#define GUARD_DELAY 0           /* Задержка между отправкой последовательных команд в модуль DFPlayer 0..15 мс */
                                // Рекомендуется подбирать опытным путем. Слишком большая задержка может давать суммарно до 0.5 сек замирания эффектов при начале/окончании воспроизведения звука.
                                // Слишком маленькая задержка может приводить к необнаружению плеера прошивкой или даже циклическую перезагрузку контроллера
                                // Если плеер обнаруживается прошивкой, но не удается получить список файлов с SD-карты и в приложении отсутствует выбор звуков
                                // будильника - увеличивайте значение задержки
// -------
// Схемы подключения для ESP32 - в папке Schemes
/*
## Назначение пинов SPI по версии объявления пинов в ядре микроконтроллера:
## Для конкретной платы смотреть в папке C:\Users\AlVa\Local Settings\Arduino15\packages\esp32\hardware\esp32\2.0.14\variants
  
| SPI Pin Name | ESP32  | ESP32-S2 | S2-MINI | ESP32-C3 | C3-MINI | ESP32-S3 | S3-MINI |
|--------------|--------|----------|---------|----------|---------|----------|---------|
| CS  (SS)     | GPIO5  | GPIO34   | GPIO12  | GPIO7    | GPIO5   | GPIO10   | GPIO10  | 
| DI  (MOSI)   | GPIO23 | GPIO35   | GPIO11  | GPIO6    | GPIO4   | GPIO11   | GPIO11  |
| DO  (MISO)   | GPIO19 | GPIO37   | GPIO9   | GPIO5    | GPIO3   | GPIO13   | GPIO13  |
| SCLK(SCK)    | GPIO18 | GPIO36   | GPIO7   | GPIO4    | GPIO2   | GPIO12   | GPIO12  |
*/

// Пин выбора SD карты - !!!-не менять-!!! - используется аппаратная SPI-шина, пины определены в таблице выше
// Рекомендуемый к использованию шилд SD-карты: https://aliexpress.ru/item/32578362865.html
#define SD_CS_PIN (SS)  // подключение к пинам SD-shild: D8(CS), D5(CLK), D6(MISO), D7(MOSI)

/*
| I2C Pin Name | ESP32  | ESP32-S2 | S2-MINI  | ESP32-C3 | C3-MINI  | ESP32-S3 | S3-MINI |
|--------------|--------|----------|----------|----------|----------|----------|---------|
| SDA          | GPIO21 | GPIO8    | GPIO33   | GPIO8    | GPIO8    | GPIO8    | GPIO35  |
| SCL          | GPIO22 | GPIO9    | GPIO35   | GPIO9    | GPIO10   | GPIO9    | GPIO36  |
*/

#define DIO (SDA)               // TM1637 display DIO pin - специализированная шина I2С - G21(SDA/DIO), но можно использовать другие пины 
#define CLK (SCL)               // TM1637 display CLK pin - специализированная шина I2С - G22(SCL/CLK), но можно использовать другие пины

// Следите, чтобы пины при включенной фиче не пересекались, иначе одна фича будет устанавливать сигнал на пине, другая снимать и ничего работать не будет
// Настраивайте эти пины из WEBUI, там есть контроль назначения пинов, исключающий их пересечение

#if (CONFIG_IDF_TARGET_ESP32)
  // ESP32-WROOM-32, LOLIN-D1-MINI-32 -> 'ESP32 Dev Module',  'LOLIN D32'
  #define LED_PIN (13U)         // пин ленты
  #define PIN_BTN (15U)         // кнопка подключена сюда (PIN --- КНОПКА --- GND)
  #define SRX (16U)             // !!!-не менять-!!! -- G16 'RX2' пин ESP32, подключен в TX пин (3) модуля DFPlayer - используется аппаратный Serial2 - Только RX2/TX2 - GPIO 16/17
  #define STX (17U)             // !!!-не менять-!!! -- G17 'TX2' пин ESP32, подключен в RX пин (2) модуля DFPlayer - используется аппаратный Serial2 - Только RX2/TX2 - GPIO 16/17
  #define POWER_PIN (26U)       // G26 управляющий пин вкл/выкл матрицы через MOSFET или реле
  #define ALARM_PIN (25U)       // G25 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
  #define AUX_PIN (27U)         // G27 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW  
#elif (CONFIG_IDF_TARGET_ESP32S2)
/*  
  // ESP32-S2               ->  'ESP32S2 Dev Module'
  #define LED_PIN (13U)         // пин ленты
  #define PIN_BTN (15U)         // кнопка подключена сюда (PIN --- КНОПКА --- GND)
  #define SRX (16U)             // пин ESP32, который подключен в TX пин (3) модуля DFPlayer
  #define STX (17U)             // пин ESP32, который подключен в RX пин (2) модуля DFPlayer
  #define POWER_PIN (6U)        // G6 управляющий пин вкл/выкл матрицы через MOSFET или реле
  #define ALARM_PIN (5U)        // G5 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
  #define AUX_PIN (4U)          // G4 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW
 */ 
  // ESP32-S2-MINI          ->  'LOLIN S2 mini'
  #define LED_PIN (15U)         // пин ленты
  #define PIN_BTN (3U)          // кнопка подключена сюда (PIN --- КНОПКА --- GND)
  #define SRX (18U)             // пин ESP32, который подключен в TX пин (3) модуля DFPlayer
  #define STX (16U)             // пин ESP32, который подключен в RX пин (2) модуля DFPlayer
  #define POWER_PIN (1U)        // G6 управляющий пин вкл/выкл матрицы через MOSFET или реле
  #define ALARM_PIN (2U)        // G5 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
  #define AUX_PIN (4U)          // G4 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW
#elif (CONFIG_IDF_TARGET_ESP32S3)
  // ESP32-S3               ->  'ESP32S3 Dev Module'
  #define LED_PIN (14U)         // пин ленты
  #define PIN_BTN (7U)          // кнопка подключена сюда (PIN --- КНОПКА --- GND)
  #define SRX (16U)             // пин ESP32, который подключен в TX пин (3) модуля DFPlayer
  #define STX (17U)             // пин ESP32, который подключен в RX пин (2) модуля DFPlayer
  #define POWER_PIN (6U)        // G6 управляющий пин вкл/выкл матрицы через MOSFET или реле
  #define ALARM_PIN (5U)        // G5 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
  #define AUX_PIN (4U)          // G4 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW
/*  
  // ESP32-S3-MINI          ->  'LOLIN S3 mini'
  #define LED_PIN (14U)         // пин ленты
  #define PIN_BTN (15U)         // кнопка подключена сюда (PIN --- КНОПКА --- GND)
  #define SRX (16U)             // пин ESP32, который подключен в TX пин (3) модуля DFPlayer
  #define STX (17U)             // пин ESP32, который подключен в RX пин (2) модуля DFPlayer
  #define POWER_PIN (6U)        // G6 управляющий пин вкл/выкл матрицы через MOSFET или реле
  #define ALARM_PIN (5U)        // G5 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
  #define AUX_PIN (4U)          // G4 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW
*/
#elif (CONFIG_IDF_TARGET_ESP32C3)
  // ESP32-C3               ->  'ESP32C3 Dev Module'     
  #define LED_PIN (1U)          // пин ленты
  #define PIN_BTN (0U)          // кнопка подключена сюда (PIN --- КНОПКА --- GND)
  #define SRX (2U)              // пин ESP32, который подключен в TX пин (3) модуля DFPlayer
  #define STX (3U)              // пин ESP32, который подключен в RX пин (2) модуля DFPlayer
  #define POWER_PIN (18U)       // G18 управляющий пин вкл/выкл матрицы через MOSFET или реле
  #define ALARM_PIN (19U)       // G19 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
  #define AUX_PIN (19U)         // G19 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW
/*             
  // ESP32-C3-SUPER-MINI    ->  'LOLIN C3 Mini'
  #define LED_PIN (1U)          // пин ленты
  #define PIN_BTN (0U)          // кнопка подключена сюда (PIN --- КНОПКА --- GND)
  #define SRX (6U )             // пин ESP32, который подключен в TX пин (3) модуля DFPlayer
  #define STX (7U)              // пин ESP32, который подключен в RX пин (2) модуля DFPlayer
  #define POWER_PIN (9U)        // G9 управляющий пин вкл/выкл матрицы через MOSFET или реле
  #define ALARM_PIN (9U)        // G9 управляющий пин вкл/выкл доп.оборудование при срабатывании будильника через MOSFET / реле; ALARM_ON - HIGH, ALARM_OFF - LOW
  #define AUX_PIN (9U)          // G9 управляющий пин вкл/выкл доп.оборудование режимы по времени через MOSFET / реле; AUX_ON - HIGH, AUX_OFF - LOW
*/
#endif

#define DEBUG_SERIAL 1          /* включить/выключить отладочный вывод в Serial: 0 - выключено 1 - включено */

#endif

// =======================================================

#if (A_DEF_DEVC == 1)
#include "a_def_devc.h"         // Если здесь ошибка - смотри комментарий к определению A_DEF_DEVC выше в начале этого файла (строка 49)
#endif

#include "a_def_lang.h"         // Определение языка интерфейса для параметров, передаваемых в приложение управления или WEB-интерфейс

// =======================================================

// ************** ИСПОЛЬЗУЕМЫЕ БИБЛИОТЕКИ ****************

#include "core_version.h"

#if defined(ESP8266)
  #include <ESP8266WiFi.h>
  #include <ESP8266mDNS.h>
#endif

#if defined(ESP32)
  #include <WiFi.h>
  #include <ESPmDNS.h>
#endif

                                 // Начиная с версии 3.9.2 FastLED допускает оверклокинг - повышенную частоту вывода сигнала в линию
                                 // Если диодов много - можно попробовать увеличить частоту вывода на ленту, установив некоторое значение оверклокинга
#define FASTLED_OVERCLOCK 1.0    // 1.2 -> 20% overclock ~ 960 khz.
#include <FastLED.h>             // Установите в менеджере библиотек стандартную библиотеку FastLED

#include <ESPAsyncWebServer.h>   // Библиотека асинхронного Web-сервера

#if (USE_OTA == 1)
  #include <ArduinoOTA.h>        // Библиотека обновления "по воздуху"
#endif

#include <EEPROM.h>              // Библиотека поддержки постоянной памяти
#include <ArduinoJson.h>         // Библиотека для работы с JSON (погода, состояние системы)
    
#if (USE_TM1637 == 1)
#include "TM1637Display.h"       // Внимание!!! Библиотека в папке проекта libraries изменена - константы букв и цифр переименованы с вида _1, _A на _1_, _A_ из-за ошибок компиляции для ESP32
#endif 

#include "timerMinim.h"          // Библиотека таймеров
#include "fonts.h"               // Шрифты, определенные для бегущей строки

#if (USE_BUTTON == 1)
#include "GyverButton.h"         // Библиотека поддержки кнопок
#endif

#if (USE_MP3 == 1)

#if defined(ESP32)
#include <HardwareSerial.h>
#else
#include "SoftwareSerial.h"
#endif
#include "DFMiniMp3.h"           // Установите в библиотеку DFMiniMp3 от Makuha по следующей ссылке: ("DFPlayer Mini MP3 by Makuna" https://github.com/Makuna/DFMiniMp3)
#endif                           // Внимание - НЕ ИЗ МЕНЕДЖЕРА БИБЛИОТЕК. В менеджере в настоящее время версия 1.07, по ссылке 1.10. Скетч использует функции, которых нет в 1.07


#if (USE_SD == 1 && FS_AS_SD == 0)
#include <SPI.h>                 // Библиотеки поддержки работы с SD-картой (если НЕ используется режим эмуляции FS as SD)
#include <SD.h>
#endif

#if (USE_E131 == 1)              // Внимание!!! Библиотека в папке проекта libraries изменена - исправлены ошибки, добавлен деструктор, добавлены функции multicast-отправки пакета
#include <ESPAsyncE131.h>        // Библиотека приема потока по протоколу E1.31; Требует установленной библиотеки ESPAcyncUDP
#endif

#include "FS.h"                  // Работа с внутренней файловой системой чипа ESP8266/ESP32
#include <LittleFS.h>            // Формат файловой системы - LittleFS

// =======================================================

#if (A_DEF_PASS == 1)
#include "a_def_pass.h"          // Если здесь ошибка - смотри комментарий к определению A_DEF_PASS выше в начале этого файла (строка 54)
#endif

// =======================================================

#define DEBUGLN(x)    if (vDEBUG_SERIAL) Serial.println(x)
#define DEBUG(x)      if (vDEBUG_SERIAL) Serial.print(x)
#define DEBUGR(x, r)  if (vDEBUG_SERIAL) Serial.print(x, r)
#define DEBUGWR(b, l) if (vDEBUG_SERIAL) Serial.write(b, l)
#define DEBUGLOG(func, ...) if (vDEBUG_SERIAL) Serial.func(__VA_ARGS__)

// =======================================================

// Длина строки по умолчанию в очереди входящих / исходящих команд
// Большинство взодящих команд - короткие, до 25 символов.
// Длинные команды:
// - группа команд текстового блока:
//   - запрос параметров '$6 7/список', но она обрабатывается сразу при поступлении и в очередь не помещаеnся
//   - установка параметров будильника '$6 6|DD EF WD AD HH1 MM1 HH2 MM2 HH3 MM3 HH4 MM4 HH5 MM5 HH6 MM6 HH7 MM7'
//   - передача картинки с матрицы для сохранения '$6 11|Y colorHEX,colorHEX,...,colorHEX' - зависит от размеров матрицы
//   - передача картинки с матрицы для сохранения '$6 12|X colorHEX,colorHEX,...,colorHEX' - зависит от размеров матрицы
//   - работа со строками? которые могут быть и длинными - показать / сохранить текст бегущей строки, длинные пароли
// - настройка режимов по времени '$22 HH1 MM1 NN1 HH2 MM2 NN2 HH3 MM3 NN3 HH4 MM4 NN4 NN5 NN6';
// Длинные команды поступают сравнительно редко, 80% - короткие команды
// Для экономии памяти под строку в очереди резервируется 25 символов.
// Если строки входящих команд будут длиннее - будет выделяться новое место в heap память, чтоЮ конечно, приведет к фрагментации,
// но это неизбежно 

#if defined(ESP8266)
  #define IN_CMD_SIZE 25
  #define OUT_CMD_SIZE 80
  #define OUT_TPC_SIZE 5
#else
  #define IN_CMD_SIZE 25
  #define OUT_CMD_SIZE 120
  #define OUT_TPC_SIZE 5
#endif

#if defined(ESP8266)
  // В 'NodeMCU' определены D9, D10 и не определены RX, TX
  #ifndef RX
    #define RX  3
    #define TX  1
    #define ESP8266_NODEMCU
  #endif
  // В 'Wemos d1 mini' определены RX, TX и не определены D9, D10
  #ifndef D9
    #define D9  3
    #define D10 1
    #define ESP8266_WEMOS
  #endif
#endif
